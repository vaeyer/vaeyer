<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!----------------------------------------------------------------------------------><h2 id="线性表-——-Linear-List"><a href="#线性表-——-Linear-List" class="headerlink" title="线性表 —— Linear List"></a>线性表 —— Linear List</h2><p><img src="/./images/1.png" alt="线性表"></p><h3 id="一、线性表的定义："><a href="#一、线性表的定义：" class="headerlink" title="一、线性表的定义："></a>一、线性表的定义：</h3><p><code>线性表</code>是n个具有相同特性的数据元素的有限序列。</p><h3 id="二、线性表的基本操作"><a href="#二、线性表的基本操作" class="headerlink" title="二、线性表的基本操作"></a>二、线性表的基本操作</h3><p><code>注</code>：参数代“&amp;”表示：方法运行完后，对参数修改的结果要<code>“带回来”</code></p><p>对数据的操作：创销，增删查改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">InitList(&amp;L);     <span class="hljs-comment">//初始化表：构造一个空的线性表L，分配内存空间</span><br>DestoryList(&amp;L);  <span class="hljs-comment">//销毁操作：销毁线性表，并释放线性表L所占用的内存空间</span><br><br>ListInsert(&amp;L,i,e);  <span class="hljs-comment">//插入操作：在表L中第i个位置上查入指定元素e</span><br>ListDelete(&amp;L,i,&amp;e); <span class="hljs-comment">//删除操作：删除表L中第i个位置的元素，/*并用e反回删除元素的值*/</span><br><br>LocateElem(L,e); <span class="hljs-comment">//按值查找操作</span><br>GetElem(L,i);    <span class="hljs-comment">//按位查找操作</span><br><br><span class="hljs-comment">//其它常用操作</span><br>Length(L);  <span class="hljs-comment">//求表长</span><br>Print(L);   <span class="hljs-comment">//输出操作</span><br>Empty(L);   <span class="hljs-comment">//判空操作</span><br></code></pre></td></tr></table></figure><h3 id="三、存储结构"><a href="#三、存储结构" class="headerlink" title="三、存储结构"></a>三、存储结构</h3><p><code>顺序存储</code>和<code>链式存储</code></p><h3 id="四、线性表分类"><a href="#四、线性表分类" class="headerlink" title="四、线性表分类"></a>四、线性表分类</h3><p>线性表的顺序存储：顺序表</p><p>线性表的链式存储：单双链表、循环链表</p><p>静态链表比较特殊：逻辑上离散，物理上连续</p><!----------------------------------------------------------------------------------><h2 id="顺序表——-Sequence-List"><a href="#顺序表——-Sequence-List" class="headerlink" title="顺序表—— Sequence List"></a>顺序表—— Sequence List</h2><h3 id="一、顺序表的定义"><a href="#一、顺序表的定义" class="headerlink" title="一、顺序表的定义"></a>一、顺序表的定义</h3><p><code>顺序表</code>：线性表的<code>顺序存储</code>，它是用一组地址连续的存储单元依次存储线性表中的数据元素，使得<strong>逻辑上相邻的两个元素在物理位置上也相邻</strong>。</p><h3 id="二、顺序表的特点"><a href="#二、顺序表的特点" class="headerlink" title="二、顺序表的特点"></a>二、顺序表的特点</h3><p>①随机访问：可直接通过下标访问</p><p>②存储密度高：每个节点只能存数据元素</p><p>③拓展容量不方便：即便采用动态分配方式，迁移数据时时间复杂度也比较高</p><p>④插入、删除操作不方便：需要移动大量元素</p><h3 id="三、顺序表的实现方式"><a href="#三、顺序表的实现方式" class="headerlink" title="三、顺序表的实现方式"></a>三、顺序表的实现方式</h3><p>实现方式：<code>静态分配</code>和<code>动态分配</code></p><h3 id="四、静态分配的顺序表上的操作"><a href="#四、静态分配的顺序表上的操作" class="headerlink" title="四、静态分配的顺序表上的操作"></a>四、静态分配的顺序表上的操作</h3><h4 id="静态分配的顺序表的优缺点"><a href="#静态分配的顺序表的优缺点" class="headerlink" title="静态分配的顺序表的优缺点"></a>静态分配的顺序表的优缺点</h4><p><code>缺点</code>：顺序表的表长确定后无法修改，存满了就存不了了</p><h4 id="顺序表的类型描述"><a href="#顺序表的类型描述" class="headerlink" title="顺序表的类型描述"></a>顺序表的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10; <span class="hljs-comment">//定义最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> data[MaxSize];       <span class="hljs-comment">//“静态”的数组存数据，存int数据</span><br>    <span class="hljs-type">int</span> length;              <span class="hljs-comment">//顺序表的当前长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(SqList &amp;L)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;MaxSize; i++)&#123;<br>        L.data=[i]=<span class="hljs-number">0</span>;     <span class="hljs-comment">//将所有元素都设为默认值0</span><br>    &#125;<br>    L.length=<span class="hljs-number">0</span>;              <span class="hljs-comment">//顺序表长度初始为0</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//插入操作：在顺序表L的第i个(位序)上插入x</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i,<span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)<span class="hljs-comment">//判断i的范围是否有效</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(L.length&gt;=MaxSize)<span class="hljs-comment">//当存储空间已满时，不能插入</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=L.length; j&gt;=i; j--)<br>        L.data[j]=L.data[j<span class="hljs-number">-1</span>];  <span class="hljs-comment">//将第i个及后面的元素后移</span><br>    L.data[i<span class="hljs-number">-1</span>]=e;<span class="hljs-comment">//将e放到第i个位置</span><br>    L.length++;                 <span class="hljs-comment">//长度+1</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入的时间复杂度："><a href="#插入的时间复杂度：" class="headerlink" title="插入的时间复杂度："></a>插入的时间复杂度：</h5><p>最好情况：插到表尾，不需移动元素，循环0次，<code>最好时间复杂度</code>&#x3D;O(1)</p><p>最坏情况：插到表头，移动n个元素，循环n次，<code>最坏时间复杂度</code>&#x3D;O(n)</p><p>平均情况：设插入概率为p&#x3D;1&#x2F;n+1，则循环np+(n-1)p+…+1p&#x3D;n&#x2F;2，<code>平均时间复杂度</code>&#x3D;O(n)</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除操作：删除顺序表L中第i个元素并返回其元素值</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i,<span class="hljs-type">int</span> &amp;e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)&#123;       <span class="hljs-comment">//判断i的范围是否有效</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        e = L.data[i<span class="hljs-number">-1</span>];               <span class="hljs-comment">//将被删除的元素赋值给e</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;L.length; j++)&#123;<br>            L.data[j]=L.data[j<span class="hljs-number">-1</span>];     <span class="hljs-comment">//将第i个后面的元素前移</span><br>        &#125;<br>    L.length--;                    <span class="hljs-comment">//长度-1</span><br>        <span class="hljs-keyword">return</span> ture;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除的时间复杂度："><a href="#删除的时间复杂度：" class="headerlink" title="删除的时间复杂度："></a>删除的时间复杂度：</h5><p>最好情况：删除表尾，不需移动元素，循环0次，<code>最好时间复杂度</code>&#x3D;O(1)</p><p>最坏情况：删除表头，移动n-1个元素，循环n次，<code>最坏时间复杂度</code>&#x3D;O(n)</p><p>平均情况：设删除概率为p&#x3D;1&#x2F;n，则循环(n-1)p+(n-2)p+…+1p&#x3D;(n-1)&#x2F;2，<code>平均时间复杂度</code>&#x3D;O(n)</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h5 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按位查找：返回顺序表中第i个元素的元素值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetElem</span><span class="hljs-params">(Sqlist L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">return</span> L.data[i<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="按位查找的时间复杂度"><a href="#按位查找的时间复杂度" class="headerlink" title="按位查找的时间复杂度"></a>按位查找的时间复杂度</h6><p>时间复杂度&#x3D;O(1)</p><h5 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按值查找：返回顺序表L中第一个值为x的元素的位置</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(Sqlist L, <span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;L.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(L.data[i] == e)<br>            <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;  <span class="hljs-comment">//返回元素位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">//查找失败，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="按值查找的时间复杂度"><a href="#按值查找的时间复杂度" class="headerlink" title="按值查找的时间复杂度"></a>按值查找的时间复杂度</h6><p>最好情况：目标在表头，循环1次，<code>最好时间复杂度</code>&#x3D;O(1)</p><p>最坏情况：目标在表尾，循环n次，<code>最坏时间复杂度</code>&#x3D;O(n)</p><p>平均情况：设删除概率为p&#x3D;1&#x2F;n，则循环(n-1)p+(n-2)p+…+1p&#x3D;(n+1)&#x2F;2，<code>平均时间复杂度</code>&#x3D;O(n)</p><h4 id="无销毁"><a href="#无销毁" class="headerlink" title="无销毁"></a>无销毁</h4><p>系统自动销毁</p><h3 id="五、动态分配的顺序表上的操作"><a href="#五、动态分配的顺序表上的操作" class="headerlink" title="五、动态分配的顺序表上的操作"></a>五、动态分配的顺序表上的操作</h3><h4 id="动态分配的顺序表的优缺点："><a href="#动态分配的顺序表的优缺点：" class="headerlink" title="动态分配的顺序表的优缺点："></a>动态分配的顺序表的优缺点：</h4><p><code>优点</code>：可以动态增加长度</p><p><code>缺点</code>：动态增加长度中的迁移工作时间开销大</p><h4 id="顺序表的类型描述-1"><a href="#顺序表的类型描述-1" class="headerlink" title="顺序表的类型描述"></a>顺序表的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> *data;         <span class="hljs-comment">//指向“动态”分配的数组的指针</span><br>    <span class="hljs-type">int</span> MaxSize;   <span class="hljs-comment">//顺序表的最大长度</span><br>    <span class="hljs-type">int</span> length;        <span class="hljs-comment">//顺序表的当前长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(SqList &amp;L)</span>&#123;<br>    <span class="hljs-comment">//用malloc函数申请一片连续的存储空间</span><br>    L.data=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(InitSize*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    L.MaxSize=InitSize;<br>    L.length=<span class="hljs-number">0</span>;              <span class="hljs-comment">//顺序表长度初始为0</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态增加数组长度"><a href="#动态增加数组长度" class="headerlink" title="动态增加数组长度"></a>动态增加数组长度</h4><p>方法：借用一个指针指向原来顺序表，新建一个更大的顺序表，将原数据迁移过来，并更改顺序表大小，最后释放原顺序表空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//动态分配</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">IncreaseSize</span><span class="hljs-params">(SqlList &amp;L, <span class="hljs-type">int</span> len)</span>&#123;<br>    <span class="hljs-type">int</span> *p=L.data;<br>    L.data=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>((L.InitSize+len)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;L.length; i++)&#123;<br>        L.data[i]=p[i];<span class="hljs-comment">//将数据迁移至新区域</span><br>    &#125;<br>    L.MaxSize=L.MaxSize+len;<span class="hljs-comment">//顺序表最大长度+len</span><br>    <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//释放原来的内存空间</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>在静态分配的基础上，如果容量不够，则动态增加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//插入操作：在顺序表L的第i个(位序)上插入x</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i,<span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)<span class="hljs-comment">//判断i的范围是否有效</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(L.length&gt;=MaxSize)<span class="hljs-comment">//当存储空间已满时，动态增加数组长度</span><br>        IncreaseSize(L,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=L.length; j&gt;=i; j--)<br>        L.data[j]=L.data[j<span class="hljs-number">-1</span>];  <span class="hljs-comment">//将第i个及后面的元素后移</span><br>    L.data[i<span class="hljs-number">-1</span>]=e;<span class="hljs-comment">//将e放到第i个位置</span><br>    L.length++;                 <span class="hljs-comment">//长度+1</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入的时间复杂度：-1"><a href="#插入的时间复杂度：-1" class="headerlink" title="插入的时间复杂度："></a>插入的时间复杂度：</h5><p>最好情况：插到表尾，不需移动元素，循环0次，<code>最好时间复杂度</code>&#x3D;O(1)</p><p>最坏情况：插到表头，移动n个元素，循环n次，<code>最坏时间复杂度</code>&#x3D;O(n)</p><p>平均情况：设插入概率为p&#x3D;1&#x2F;n+1，则循环np+(n-1)p+…+1p&#x3D;n&#x2F;2，<code>平均时间复杂度</code>&#x3D;O(n)</p><h4 id="删除-与静态一样"><a href="#删除-与静态一样" class="headerlink" title="删除(与静态一样)"></a>删除(与静态一样)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除操作：删除顺序表L中第i个元素并返回其元素值</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i,<span class="hljs-type">int</span> &amp;e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)&#123;       <span class="hljs-comment">//判断i的范围是否有效</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        e = L.data[i<span class="hljs-number">-1</span>];               <span class="hljs-comment">//将被删除的元素赋值给e</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;L.length; j++)&#123;<br>            L.data[j]=L.data[j<span class="hljs-number">-1</span>];     <span class="hljs-comment">//将第i个后面的元素前移</span><br>        &#125;<br>    L.length--;                    <span class="hljs-comment">//长度-1</span><br>        <span class="hljs-keyword">return</span> ture;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除的时间复杂度：-1"><a href="#删除的时间复杂度：-1" class="headerlink" title="删除的时间复杂度："></a>删除的时间复杂度：</h5><p>最好情况：删除表尾，不需移动元素，循环0次，<code>最好时间复杂度</code>&#x3D;O(1)</p><p>最坏情况：删除表头，移动n-1个元素，循环n次，<code>最坏时间复杂度</code>&#x3D;O(n)</p><p>平均情况：设删除概率为p&#x3D;1&#x2F;n，则循环(n-1)p+(n-2)p+…+1p&#x3D;(n-1)&#x2F;2，<code>平均时间复杂度</code>&#x3D;O(n)</p><h4 id="查找-与静态一样"><a href="#查找-与静态一样" class="headerlink" title="查找(与静态一样)"></a>查找(与静态一样)</h4><h5 id="按位查找-1"><a href="#按位查找-1" class="headerlink" title="按位查找"></a>按位查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按位查找：返回顺序表中第i个元素的元素值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetElem</span><span class="hljs-params">(Sqlist L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">return</span> L.data[i<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="按位查找的时间复杂度-1"><a href="#按位查找的时间复杂度-1" class="headerlink" title="按位查找的时间复杂度"></a>按位查找的时间复杂度</h6><p>时间复杂度&#x3D;O(1)</p><h5 id="按值查找-1"><a href="#按值查找-1" class="headerlink" title="按值查找"></a>按值查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按值查找：返回顺序表L中第一个值为x的元素的位置</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(Sqlist L, <span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;L.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(L.data[i] == e)<br>            <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;  <span class="hljs-comment">//返回元素位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">//查找失败，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="按值查找的时间复杂度-1"><a href="#按值查找的时间复杂度-1" class="headerlink" title="按值查找的时间复杂度"></a>按值查找的时间复杂度</h6><p>最好情况：目标在表头，循环1次，<code>最好时间复杂度</code>&#x3D;O(1)</p><p>最坏情况：目标在表尾，循环n次，<code>最坏时间复杂度</code>&#x3D;O(n)</p><p>平均情况：设删除概率为p&#x3D;1&#x2F;n，则循环(n-1)p+(n-2)p+…+1p&#x3D;(n+1)&#x2F;2，<code>平均时间复杂度</code>&#x3D;O(n)</p><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//销毁操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DestroyList</span><span class="hljs-params">(Sqlist &amp;L)</span>&#123;<br>    <span class="hljs-built_in">free</span>(L.data);<br>    L.length = <span class="hljs-number">0</span>;<br>    L.MaxSize = <span class="hljs-number">0</span>;<br>    L.data = nullptr;  <span class="hljs-comment">//令其为空指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="六、共同的操作"><a href="#六、共同的操作" class="headerlink" title="六、共同的操作"></a>六、共同的操作</h3><h4 id="求表长"><a href="#求表长" class="headerlink" title="求表长"></a>求表长</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求表长</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Length</span><span class="hljs-params">(Sqlist L)</span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//遍历操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintList</span><span class="hljs-params">(Sqlist L)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;L.length; i++)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;L.data[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判空操作</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Empty</span><span class="hljs-params">(Sqlist L)</span>&#123;<br>    <span class="hljs-keyword">return</span> L.length==<span class="hljs-number">0</span>? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="七、完整代码"><a href="#七、完整代码" class="headerlink" title="七、完整代码"></a>七、完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//动态分配的顺序表的完整代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 100   <span class="hljs-comment">//定义线性表的最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sqlist</span>&#123;</span><br><span class="hljs-type">int</span> data[MaxSize];<br><span class="hljs-type">int</span> length;<br>&#125;Sqlist;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Init</span><span class="hljs-params">(Sqlist &amp;L)</span>&#123;<br>    L.length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//求表长</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Length</span><span class="hljs-params">(Sqlist L)</span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br><br><span class="hljs-comment">//插入操作：在表中第i个位置上插入x</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(Sqlist &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L.length+<span class="hljs-number">1</span> || L.length &gt;= MaxSize)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; Insert failed.&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=L.length; j&gt;=i; j--)&#123;  <span class="hljs-comment">//第i个及以后的元素后移</span><br>        L.data[j] = L.data[j<span class="hljs-number">-1</span>];<br>    &#125;<br>    L.data[i<span class="hljs-number">-1</span>]=x;<br>    L.length++;<br>&#125;<br><br><span class="hljs-comment">//遍历操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintList</span><span class="hljs-params">(Sqlist L)</span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;L: &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;L.length; i++)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;L.data[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//按值查找：返回顺序表L中第一个值为x的元素的位置</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(Sqlist L, <span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;L.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(L.data[i] == x)<br>            <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;  <span class="hljs-comment">//返回元素位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">//查找失败，返回-1</span><br>&#125;<br><br><span class="hljs-comment">//按位查找：返回顺序表中第i个元素的元素值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">GetElem</span><span class="hljs-params">(Sqlist L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">return</span> L.data[i<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-comment">//删除操作：删除顺序表L中第i个元素并返回其元素值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">(Sqlist &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L.length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        x = L.data[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i; j&lt;L.length; j++)&#123;<br>            L.data[j<span class="hljs-number">-1</span>] = L.data[j];<br>        &#125;<br>        L.length--;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//判空操作</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Empty</span><span class="hljs-params">(Sqlist L)</span>&#123;<br>    <span class="hljs-keyword">return</span> L.length==<span class="hljs-number">0</span>? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    Sqlist L;<br>    Init(L); <br>    Insert(L, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>);<br>    Insert(L, <span class="hljs-number">2</span>, <span class="hljs-number">60</span>);<br>    Insert(L, <span class="hljs-number">1</span>, <span class="hljs-number">40</span>);<br>    Insert(L, <span class="hljs-number">1</span>, <span class="hljs-number">666</span>);<br>    Insert(L, <span class="hljs-number">5</span>, <span class="hljs-number">70</span>);<br>    Insert(L, <span class="hljs-number">6</span>, <span class="hljs-number">40</span>);<br>    Insert(L, <span class="hljs-number">7</span>, <span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;长度：&quot;</span>&lt;&lt;Length(L)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    PrintList(L);<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;第三个元素是：&quot;</span>&lt;&lt;GetElem(L,<span class="hljs-number">3</span>)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;40在第&quot;</span>&lt;&lt;LocateElem(L,<span class="hljs-number">40</span>)&lt;&lt;<span class="hljs-string">&quot;位&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;删除&quot;</span>&lt;&lt;Delete(L,<span class="hljs-number">6</span>,x)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    PrintList(L);<br>    <span class="hljs-keyword">if</span>(!Empty(L))&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;L不为空&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;L为空&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><!----------------------------------------------------------------------------------><h2 id="单链表——-Singly-Linked-List"><a href="#单链表——-Singly-Linked-List" class="headerlink" title="单链表—— Singly Linked List"></a>单链表—— Singly Linked List</h2><h3 id="一、单链表的定义"><a href="#一、单链表的定义" class="headerlink" title="一、单链表的定义"></a>一、单链表的定义</h3><p><code>单链表</code>：线性表的<code>链式存储</code>，它是通过一组任意的存储单元来存储线性表中的数据元素，不需要使用地址连续的存储单元，因此它不要求在逻辑上相邻的两个元素在物理位置上也相邻。</p><h3 id="二、单链表的特点"><a href="#二、单链表的特点" class="headerlink" title="二、单链表的特点"></a>二、单链表的特点</h3><p>①不能随机访问：遍历查找访问</p><p>②存储密度不高：每个节点既要存数据元素又要存指针</p><p>③拓展容量方便：直接用建立单链表拓展</p><p>④插入、删除操作方便：知道位置直接插入和删除</p><h3 id="三、单链表的实现方式"><a href="#三、单链表的实现方式" class="headerlink" title="三、单链表的实现方式"></a>三、单链表的实现方式</h3><p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般带头结点比不带头结点好</p><p>带头结点：写操作代码方便，一般用带头结点，不明确的都是带头结点的</p><p>不带头结点：写操作代码麻烦，要区分第一个数据和后续数据的处理</p><p><code>注</code>：这两种方式主要是：类型描述相同，初始化和判空不同</p><h3 id="四、单链表上的操作"><a href="#四、单链表上的操作" class="headerlink" title="四、单链表上的操作"></a>四、单链表上的操作</h3><h4 id="单链表的类型描述"><a href="#单链表的类型描述" class="headerlink" title="单链表的类型描述"></a>单链表的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>    <span class="hljs-comment">//定义单链表结点类型</span><br><span class="hljs-type">int</span> data;            <span class="hljs-comment">//数据域，可以是别的各种数据类型，本文统一用int类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//指针域</span><br>&#125;LNode, *LinkList;<br></code></pre></td></tr></table></figure><h4 id="初始化和判空"><a href="#初始化和判空" class="headerlink" title="初始化和判空"></a>初始化和判空</h4><p><img src="https://img-blog.csdnimg.cn/20210417193902102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE2MjM2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="不带头结点的初始化和判空"><a href="#不带头结点的初始化和判空" class="headerlink" title="不带头结点的初始化和判空"></a>不带头结点的初始化和判空</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(LinkList &amp;L)</span>&#123;<br>    L = <span class="hljs-literal">NULL</span>;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判空操作</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Empty</span><span class="hljs-params">(LinkList L)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="带头结点的初始化和判空"><a href="#带头结点的初始化和判空" class="headerlink" title="带头结点的初始化和判空"></a>带头结点的初始化和判空</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(LinkList &amp;L)</span>&#123;<br>    L = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkList));<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判空操作</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Empty</span><span class="hljs-params">(LinkList L)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="建立单链表"><a href="#建立单链表" class="headerlink" title="建立单链表"></a>建立单链表</h4><h5 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h5><p>用于链表的逆置</p><p><img src="https://img-blog.csdnimg.cn/20210417202853466.png" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//头插法建立单链表</span><br>LinkList <span class="hljs-title function_">HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span>&#123;<br>    InitList(L); <span class="hljs-comment">//初始化</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123; <span class="hljs-comment">//输入9999表示结束</span><br>        LNode *s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        s-&gt;data = x;<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h5><p><img src="https://img-blog.csdnimg.cn/20210417204450775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE2MjM2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//尾插法建立单链表</span><br>LinkList <span class="hljs-title function_">TailInsert</span><span class="hljs-params">(LinkList &amp;L)</span>&#123;<br>    InitList(L);<br>    LNode *s,*r=L;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        s-&gt;data = x;<br>        r-&gt;next = s;<br>        r = s;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h4><p><code>时间复杂度</code>&#x3D;O(1)</p><h5 id="带头结点的插入"><a href="#带头结点的插入" class="headerlink" title="带头结点的插入"></a>带头结点的插入</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将x插入到单链表L的第i个位置上</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LNode *p = GetElem(L,i<span class="hljs-number">-1</span>);    <span class="hljs-comment">//查找第i个位置</span><br>    <span class="hljs-keyword">return</span> InsertNextNode(p, e);  <span class="hljs-comment">//用后插操作，插在p后面</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="不带头结点的插入"><a href="#不带头结点的插入" class="headerlink" title="不带头结点的插入"></a>不带头结点的插入</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将x插入到单链表L的第i个位置上</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>        LNode *s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    s-&gt;data = e;<br>    s-&gt;next = L;<br>    L = s;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    LNode *p = GetElem(L,i<span class="hljs-number">-1</span>);    <span class="hljs-comment">//查找第i个位置</span><br>    <span class="hljs-keyword">return</span> InsertNextNode(p, e);  <span class="hljs-comment">//用后插操作，插在p后面</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="指定结点的后插操作"><a href="#指定结点的后插操作" class="headerlink" title="指定结点的后插操作"></a>指定结点的后插操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//后插操作：在p结点之后插入元素e</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InsertNextNode</span><span class="hljs-params">(LNode *p, <span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LNode *s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br><span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s-&gt;data = e;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="指定结点的前插操作"><a href="#指定结点的前插操作" class="headerlink" title="指定结点的前插操作"></a>指定结点的前插操作</h5><p>还是插在p后面，只不过让p和插入结点的值交换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//前插操作：在p结点之前插入元素e</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InsertPriorNode</span><span class="hljs-params">(LNode *p, <span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LNode *s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br><span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    s-&gt;data = p-&gt;data;<br>    p-&gt;data = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><h5 id="按位序删除"><a href="#按位序删除" class="headerlink" title="按位序删除"></a>按位序删除</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除操作:将单链表中的第i个结点删除</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i <span class="hljs-type">int</span> &amp;e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;Length(L))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LNode *p = GetElem(L,i<span class="hljs-number">-1</span>);  <span class="hljs-comment">//查找第i个位置</span><br>    LNode *q = p-&gt;next;<br>    e = q-&gt;data;<br>    p-&gt;next = q-&gt;next;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="按位序删除的时间复杂度："><a href="#按位序删除的时间复杂度：" class="headerlink" title="按位序删除的时间复杂度："></a>按位序删除的时间复杂度：</h6><p>最好情况：删除第一个，不需查找位置，循环0次，<code>最好时间复杂度</code>&#x3D;O(1)</p><p>最坏情况：删除最后一个，需查找第n位，循环n次，<code>最坏时间复杂度</code>&#x3D;O(n)</p><p>平均情况：删除任意一个，<code>平均时间复杂度</code>&#x3D;O(n)</p><h5 id="指定结点的删除"><a href="#指定结点的删除" class="headerlink" title="指定结点的删除"></a>指定结点的删除</h5><p><code>时间复杂度</code>&#x3D;O(n)</p><p>方法：p的后一个为q，p指向q的下一个，把q的值给p，最后释放q</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除指定结点p</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">(LNode *p)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LNode *q = p-&gt;next;<br>    p-&gt;data = q-&gt;data<br>    p-&gt;next = q-&gt;next;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><h5 id="按位查找-2"><a href="#按位查找-2" class="headerlink" title="按位查找"></a>按位查找</h5><p><code>平均时间复杂度</code>&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按位查找：查找在单链表L中第i个位置的结点</span><br>LNode *<span class="hljs-title function_">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    LNode *p = L;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p; <span class="hljs-comment">//如果i大于表长，p=NULL,直接返回p即可</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="按值查找-2"><a href="#按值查找-2" class="headerlink" title="按值查找"></a>按值查找</h5><p><code>平均时间复杂度</code>&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按值查找：查找e在L中的位置</span><br>LNode *<span class="hljs-title function_">LocateElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> e)</span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求表长-1"><a href="#求表长-1" class="headerlink" title="求表长"></a>求表长</h4><p><code>平均时间复杂度</code>&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求表的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Length</span><span class="hljs-params">(LinkList L)</span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    LNode *p = L;<br>    <span class="hljs-keyword">while</span>(P-&gt;next)&#123;<br>        p = p-&gt;next;<br>        len++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//遍历操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintList</span><span class="hljs-params">(LinkList L)</span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、完整代码"><a href="#五、完整代码" class="headerlink" title="五、完整代码"></a>五、完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LNode, *LinkList;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(LinkList &amp;L)</span>&#123;<br>    L = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkList));<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//遍历操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintList</span><span class="hljs-params">(LinkList L)</span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//求单链表的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Length</span><span class="hljs-params">(LinkList L)</span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        len++;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br><br><span class="hljs-comment">//头插法建立单链表</span><br>LinkList <span class="hljs-title function_">HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span>&#123;<br>    InitList(L); <span class="hljs-comment">//初始化</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        LNode *s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        s-&gt;data = x;<br>        s-&gt;next = L-&gt;next;<br>        L-&gt;next = s;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><br><span class="hljs-comment">//尾插法建立单链表</span><br>LinkList <span class="hljs-title function_">TailInsert</span><span class="hljs-params">(LinkList &amp;L)</span>&#123;<br>    InitList(L);<br>    LNode *s,*r=L;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        s-&gt;data = x;<br>        r-&gt;next = s;<br>        r = s;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><br><span class="hljs-comment">//按值查找：查找x在L中的位置</span><br>LNode *<span class="hljs-title function_">LocateElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> x)</span>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != x)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//按位查找：查找在单链表L中第i个位置的结点</span><br>LNode *<span class="hljs-title function_">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> L;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p; <span class="hljs-comment">//如果i大于表长，p=NULL,直接返回p即可</span><br>&#125;<br><br><span class="hljs-comment">//将x插入到单链表L的第i个位置上</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span>&#123;<br>    LNode *p = GetElem(L,i<span class="hljs-number">-1</span>);<br>    LNode *s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    s-&gt;data = x;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>&#125;<br><br><span class="hljs-comment">//删除操作:将单链表中的第i个结点删除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;Length(L))&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;delete failed: index is wrong.&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LNode *p = GetElem(L,i<span class="hljs-number">-1</span>);<br>    LNode *q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    <span class="hljs-built_in">free</span>(q);<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//初始化，尾插法建立单链表</span><br>    LinkList L = TailInsert(L);<br>    <span class="hljs-comment">//插入：在第二个位置插入结点，数据域为888，并遍历单链表</span><br>    Insert(L,<span class="hljs-number">2</span>,<span class="hljs-number">888</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;在第二个位置插入888： &quot;</span>;<br>    PrintList(L);<br>    <span class="hljs-comment">//删除：删除第四个结点</span><br>    Delete(L,<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;删除第四个结点后：&quot;</span>;<br>    PrintList(L);<br>    <span class="hljs-comment">//按位查找：查找第三个结点，并输出其数据域的值</span><br>    LNode *p = GetElem(L,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;第三个结点的值为：&quot;</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//按值查找：查找数据域为2的结点的指针</span><br>    LNode *q = LocateElem(L,<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;数据为2的结点的下一个结点的值为：&quot;</span>&lt;&lt;q-&gt;next-&gt;data&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//输出单链表的长度</span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;单链表的长度：&quot;</span>&lt;&lt;Length(L)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="https://img-blog.csdnimg.cn/20210417234615645.png" alt="在这里插入图片描述"></p><!----------------------------------------------------------------------------------><h2 id="双链表——-Double-Linked-List"><a href="#双链表——-Double-Linked-List" class="headerlink" title="双链表—— Double Linked List"></a>双链表—— Double Linked List</h2><h3 id="一、单链表的定义-1"><a href="#一、单链表的定义-1" class="headerlink" title="一、单链表的定义"></a>一、单链表的定义</h3><p>单链表的结点中只有一个指向其后继的指针，使得单链表要访问某个结点的前驱结点时，只能从头开始遍历，访问后驱结点的复杂度为O(1)，访问前驱结点的复杂度为O(n)。为了克服上述缺点，引入了双链表。</p><p> <code>双链表</code>的结点中有两个指针<code>prior</code>和<code>next</code>，分别指向前驱结点和后继结点。</p><h3 id="二、双链表的实现方式"><a href="#二、双链表的实现方式" class="headerlink" title="二、双链表的实现方式"></a>二、双链表的实现方式</h3><p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般带头结点比不带头结点好</p><p>带头结点：写操作代码方便，一般用带头结点，不明确的都是带头结点的</p><p>不带头结点：写操作代码麻烦，要区分第一个数据和后续数据的处理</p><h3 id="三、双链表上的操作（带头结点）"><a href="#三、双链表上的操作（带头结点）" class="headerlink" title="三、双链表上的操作（带头结点）"></a>三、双链表上的操作（带头结点）</h3><h4 id="双链表的类型描述"><a href="#双链表的类型描述" class="headerlink" title="双链表的类型描述"></a>双链表的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>&#123;</span><br>    <span class="hljs-type">int</span> data;  <span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//前驱和后继指针</span><br>&#125;DNode, *DLinkList;<br></code></pre></td></tr></table></figure><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><p><img src="https://img-blog.csdnimg.cn/20210418102417468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE2MjM2MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(DLinkList &amp;L)</span>&#123;<br>    L = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLinkList));<br>    <span class="hljs-keyword">if</span>(L == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判空-1"><a href="#判空-1" class="headerlink" title="判空"></a>判空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判空操作</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Empty</span><span class="hljs-params">(DLinkList L)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="建立双链表"><a href="#建立双链表" class="headerlink" title="建立双链表"></a>建立双链表</h4><h5 id="头插法建立双链表"><a href="#头插法建立双链表" class="headerlink" title="头插法建立双链表"></a>头插法建立双链表</h5><p>用于链表的逆置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//头插法建立双链表</span><br>DLinkList <span class="hljs-title function_">HeadInsert</span><span class="hljs-params">(DLinkList &amp;L)</span>&#123;<br>    InitList(L); <span class="hljs-comment">//初始化</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        DNode *s = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DNode));<br>        s-&gt;data = x;<br>        <span class="hljs-keyword">if</span>(L-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>            s-&gt;next = <span class="hljs-literal">NULL</span>;<br>            s-&gt;prior = L;<br>            L-&gt;next = s;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            s-&gt;next = L-&gt;next;<br>            L-&gt;next-&gt;prior = s;<br>            s-&gt;prior = L;<br>            L-&gt;next = s;<br>        &#125;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="尾插法建立单链表-1"><a href="#尾插法建立单链表-1" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//尾插法建立双链表</span><br>DLinkList <span class="hljs-title function_">TailInsert</span><span class="hljs-params">(DLinkList &amp;L)</span>&#123;<br>    InitList(L);<br>    DNode *s,*r=L;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        s = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DNode));<br>        s-&gt;data = x;<br>        s-&gt;next = <span class="hljs-literal">NULL</span>;<br>        s-&gt;prior = r;<br>        r-&gt;next = s;<br>        r = s;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入-3"><a href="#插入-3" class="headerlink" title="插入"></a>插入</h4><p><code>时间复杂度</code>&#x3D;O(1)</p><p><img src="https://img-blog.csdnimg.cn/20210418105409128.jpg" alt="插入操作"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将x插入到双链表L中*p结点的下一个结点</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(DNode *p, <span class="hljs-type">int</span> x)</span>&#123;<br>    DNode *s = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DNode));<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>||s==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s-&gt;data = x;<br>    s-&gt;next = p-&gt;next;  <span class="hljs-comment">//1</span><br>    <span class="hljs-keyword">if</span>(p-&gt;next != <span class="hljs-literal">NULL</span>) p-&gt;next-&gt;prior = s; <span class="hljs-comment">//2</span><br>    s-&gt;prior = p;  <span class="hljs-comment">//3</span><br>    p-&gt;next = s; <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//在双链表L中*p结点后插入s结点</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(DNode *p, DNode *s)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>||s==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s-&gt;next = p-&gt;next;  <span class="hljs-comment">//1</span><br>    <span class="hljs-keyword">if</span>(p-&gt;next != <span class="hljs-literal">NULL</span>) p-&gt;next-&gt;prior = s; <span class="hljs-comment">//2</span><br>    s-&gt;prior = p;  <span class="hljs-comment">//3</span><br>    p-&gt;next = s; <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><h5 id="按位序删除-1"><a href="#按位序删除-1" class="headerlink" title="按位序删除"></a>按位序删除</h5><p><code>时间复杂度</code>&#x3D;O(n)</p><p><img src="https://img-blog.csdnimg.cn/20210418104109509.png" alt="删除操作"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除操作:将双链表中的第i个结点删除</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">(DLinkList &amp;L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;Length(L)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    DNode *p = GetElem(L,i<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    DNode *q = p-&gt;next;<br>    p-&gt;next = q-&gt;next; <span class="hljs-comment">//1</span><br>    <span class="hljs-keyword">if</span>(p-&gt;next != <span class="hljs-literal">NULL</span>) q-&gt;next-&gt;prior = p; <span class="hljs-comment">//2</span><br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="指定结点的删除-1"><a href="#指定结点的删除-1" class="headerlink" title="指定结点的删除"></a>指定结点的删除</h5><p><code>时间复杂度</code>&#x3D;O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除操作:删除双链表中的p结点的后继结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DeleteNextNode</span><span class="hljs-params">(DNode *p)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    DNode *q = p-&gt;next;<br>    <span class="hljs-keyword">if</span>(q == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    p-&gt;next = q-&gt;next; <span class="hljs-comment">//1</span><br>    <span class="hljs-keyword">if</span>(p-&gt;next != <span class="hljs-literal">NULL</span>) q-&gt;next-&gt;prior = p; <span class="hljs-comment">//2</span><br>    <span class="hljs-built_in">free</span>(q);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找-与单链表完全一样"><a href="#查找-与单链表完全一样" class="headerlink" title="查找(与单链表完全一样)"></a>查找(与单链表完全一样)</h4><h5 id="按位查找-3"><a href="#按位查找-3" class="headerlink" title="按位查找"></a>按位查找</h5><p><code>平均时间复杂度</code>&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按位查找：查找在单链表L中第i个位置的结点</span><br>DNode *<span class="hljs-title function_">GetElem</span><span class="hljs-params">(DLinkList L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    DNode *p = L;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p; <span class="hljs-comment">//如果i大于表长，p=NULL,直接返回p即可</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="按值查找-3"><a href="#按值查找-3" class="headerlink" title="按值查找"></a>按值查找</h5><p><code>平均时间复杂度</code>&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按值查找：查找e在L中的位置</span><br>DNode *<span class="hljs-title function_">LocateElem</span><span class="hljs-params">(DLinkList L, <span class="hljs-type">int</span> e)</span>&#123;<br>    DNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求表长-与单链表完全一样"><a href="#求表长-与单链表完全一样" class="headerlink" title="求表长(与单链表完全一样)"></a>求表长(与单链表完全一样)</h4><p><code>平均时间复杂度</code>&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求表的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Length</span><span class="hljs-params">(DLinkList L)</span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    DNode *p = L;<br>    <span class="hljs-keyword">while</span>(P-&gt;next)&#123;<br>        p = p-&gt;next;<br>        len++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="遍历-与单链表完全一样"><a href="#遍历-与单链表完全一样" class="headerlink" title="遍历(与单链表完全一样)"></a>遍历(与单链表完全一样)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//遍历操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintList</span><span class="hljs-params">(DLinkList L)</span>&#123;<br>    DNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="销毁-1"><a href="#销毁-1" class="headerlink" title="销毁"></a>销毁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//销毁操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DestoryList</span><span class="hljs-params">(DLinkList L)</span>&#123;<br>    <span class="hljs-comment">//循环释放各点的数据结点</span><br>    <span class="hljs-keyword">while</span>(L-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>        DeleteNextNode(L);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(L); <span class="hljs-comment">//释放头结点</span><br>    L = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、完整代码"><a href="#四、完整代码" class="headerlink" title="四、完整代码"></a>四、完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span><br>&#125;DNode, *DLinkList;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(DLinkList &amp;L)</span>&#123;<br>    L = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLinkList));<br>    L-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//遍历操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PrintList</span><span class="hljs-params">(DLinkList L)</span>&#123;<br>    DNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//求双链表的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Length</span><span class="hljs-params">(DLinkList L)</span>&#123;<br>    DNode *p = L-&gt;next;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        len++;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br><br><span class="hljs-comment">//头插法建立双链表</span><br>DLinkList <span class="hljs-title function_">HeadInsert</span><span class="hljs-params">(DLinkList &amp;L)</span>&#123;<br>    InitList(L); <span class="hljs-comment">//初始化</span><br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        DNode *s = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DNode));<br>        s-&gt;data = x;<br>        <span class="hljs-keyword">if</span>(L-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>            s-&gt;next = <span class="hljs-literal">NULL</span>;<br>            s-&gt;prior = L;<br>            L-&gt;next = s;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            s-&gt;next = L-&gt;next;<br>            L-&gt;next-&gt;prior = s;<br>            s-&gt;prior = L;<br>            L-&gt;next = s;<br>        &#125;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><br><span class="hljs-comment">//尾插法建立双链表</span><br>DLinkList <span class="hljs-title function_">TailInsert</span><span class="hljs-params">(DLinkList &amp;L)</span>&#123;<br>    InitList(L);<br>    DNode *s,*r=L;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        s = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DNode));<br>        s-&gt;data = x;<br>        s-&gt;next = <span class="hljs-literal">NULL</span>;<br>        s-&gt;prior = r;<br>        r-&gt;next = s;<br>        r = s;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><br><span class="hljs-comment">//按值查找：查找x在L中的位置</span><br>DNode *<span class="hljs-title function_">LocateElem</span><span class="hljs-params">(DLinkList L, <span class="hljs-type">int</span> x)</span>&#123;<br>    DNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != x)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//按位查找：查找在双链表L中第i个位置的结点</span><br>DNode *<span class="hljs-title function_">GetElem</span><span class="hljs-params">(DLinkList L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>    DNode *p = L-&gt;next;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> L;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p; <span class="hljs-comment">//如果i大于表长，p=NULL,直接返回p即可</span><br>&#125;<br><br><span class="hljs-comment">//将x插入到双链表L中*p结点的下一个结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(DLinkList &amp;L, DNode *p, <span class="hljs-type">int</span> x)</span>&#123;<br>    DNode *s = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DNode));<br>    s-&gt;data = x;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next-&gt;prior = s;<br>    s-&gt;prior = p;<br>    p-&gt;next = s;<br>&#125;<br><br><span class="hljs-comment">//删除操作:将双链表中的第i个结点删除</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">(DLinkList &amp;L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;Length(L))&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;delete failed: index is wrong.&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    DNode *p = GetElem(L,i<span class="hljs-number">-1</span>);<br>    DNode *q = p-&gt;next;<br>    p-&gt;next = q-&gt;next;<br>    q-&gt;next-&gt;prior = p;<br>    <span class="hljs-built_in">free</span>(q);<br>&#125;<br><br><span class="hljs-comment">//判空操作</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Empty</span><span class="hljs-params">(DLinkList L)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;L is null&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;L is not null&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//尾插法建立双链表，并遍历单链表</span><br>    DLinkList L = TailInsert(L);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;L: &quot;</span>;<br>    PrintList(L);<br>    <br>    DNode *p;<br>    <span class="hljs-comment">//按值查找</span><br>    p = LocateElem(L,<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;值为2的结点的下一个结点值是：&quot;</span>&lt;&lt;p-&gt;next-&gt;data&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;值为2的结点的上一个结点值是：&quot;</span>&lt;&lt;p-&gt;prior-&gt;data&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-comment">//按位查找</span><br>    p = GetElem(L,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;第三个结点值是：&quot;</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <br>    <span class="hljs-comment">//插入操作</span><br>    Insert(L,p,<span class="hljs-number">7</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;在第三个结点后面插入值为7的结点后L： &quot;</span>;<br>    PrintList(L);<br>    <br>    <span class="hljs-comment">//删除操作</span><br>    Delete(L, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;删除第五个结点后L： &quot;</span>;<br>    PrintList(L);<br>    <br>    <span class="hljs-comment">//求表长</span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;表长为：&quot;</span>&lt;&lt;Length(L)&lt;&lt;<span class="hljs-built_in">endl</span>;;<br>    <br>    <span class="hljs-comment">//判空</span><br>    Empty(L);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="https://img-blog.csdnimg.cn/20210418142232335.png" alt="在这里插入图片描述"></p><!----------------------------------------------------------------------------------><h2 id="循环链表——-Double-Linked-List"><a href="#循环链表——-Double-Linked-List" class="headerlink" title="循环链表—— Double Linked List"></a>循环链表—— Double Linked List</h2><h3 id="一、循环链表的定义"><a href="#一、循环链表的定义" class="headerlink" title="一、循环链表的定义"></a>一、循环链表的定义</h3><p><code>循环链表</code>：一般包括循环循环链表和循环循环链表，如下图所示</p><p><img src="https://img-blog.csdnimg.cn/2021041814455792.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE2MjM2MQ==,size_16,color_FFFFFF,t_70" alt="循环链表"></p><h3 id="二、循环链表的实现方式"><a href="#二、循环链表的实现方式" class="headerlink" title="二、循环链表的实现方式"></a>二、循环链表的实现方式</h3><p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般带头结点比不带头结点好</p><p>带头结点：写操作代码方便，一般用带头结点，不明确的都是带头结点的</p><p>不带头结点：写操作代码麻烦，要区分第一个数据和后续数据的处理</p><h3 id="三、循环单链表上的操作（带头结点）"><a href="#三、循环单链表上的操作（带头结点）" class="headerlink" title="三、循环单链表上的操作（带头结点）"></a>三、循环单链表上的操作（带头结点）</h3><h4 id="循环单链表的类型描述-与单链表一样"><a href="#循环单链表的类型描述-与单链表一样" class="headerlink" title="循环单链表的类型描述(与单链表一样)"></a>循环单链表的类型描述(与单链表一样)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>    <span class="hljs-comment">//定义循环链表结点类型</span><br><span class="hljs-type">int</span> data;            <span class="hljs-comment">//数据域，可以是别的各种数据类型，本文统一用int类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//指针域</span><br>&#125;LNode, *LinkList;;<br></code></pre></td></tr></table></figure><h4 id="初始化和判空-与单链表不一样"><a href="#初始化和判空-与单链表不一样" class="headerlink" title="初始化和判空(与单链表不一样)"></a>初始化和判空(与单链表不一样)</h4><p>L-&gt;next &#x3D; NULL改为L-&gt;next &#x3D; L</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(LinkList &amp;L)</span>&#123;<br>    L = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkList));<br>    L-&gt;next = L;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判空操作</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Empty</span><span class="hljs-params">(LinkList L)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L-&gt;next == L)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判断表尾结点"><a href="#判断表尾结点" class="headerlink" title="判断表尾结点"></a>判断表尾结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断结点p是否是表尾结点</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isTail</span><span class="hljs-params">(LinkList L)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;next == L)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入、删除"><a href="#插入、删除" class="headerlink" title="插入、删除"></a>插入、删除</h4><p>循环单链表的插入、删除算法与单链表几乎一样，不同的是如果在表尾进行，那么要让单链表继续<strong>保持循环的性质</strong>，即<strong>让尾结点的next域指向头结点</strong>。</p><p><code>时间复杂度</code>&#x3D;O(1)</p><h4 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h4><p>单链表的查找是从表头开始，找到表尾停止。而循环单链表中，若从表头开始查找，那与单链表的操作一致。若从表的任意位置开始查找，那么需要一个计数变量sum，当sum&#x3D;表长时还未找到，则查找失败，退出循环。</p><h4 id="求表长-2"><a href="#求表长-2" class="headerlink" title="求表长"></a>求表长</h4><p>与单链表一样</p><h4 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h4><p>单链表只能从表头结点开始往后顺序遍历整个链表，循环单链表可以从表中的<code>任意一个结点开始</code>遍历整个链表。</p><h3 id="四、循环双链表上的操作（带头结点）"><a href="#四、循环双链表上的操作（带头结点）" class="headerlink" title="四、循环双链表上的操作（带头结点）"></a>四、循环双链表上的操作（带头结点）</h3><h4 id="循环链表的类型描述"><a href="#循环链表的类型描述" class="headerlink" title="循环链表的类型描述"></a>循环链表的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span>&#123;</span><br>    <span class="hljs-type">int</span> data;  <span class="hljs-comment">//数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//前驱和后继指针</span><br>&#125;DNode, *DLinkList;<br></code></pre></td></tr></table></figure><h4 id="初始化和判空-1"><a href="#初始化和判空-1" class="headerlink" title="初始化和判空"></a>初始化和判空</h4><p>L-&gt;next &#x3D; NULL改为L-&gt;next &#x3D; L</p><p>L-&gt;prior &#x3D; NULL改为L-&gt;prior &#x3D; L</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(DLinkList &amp;L)</span>&#123;<br>    L = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLinkList));<br>    <span class="hljs-keyword">if</span>(L == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L-&gt;prior = L;<br>    L-&gt;next = L;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判空操作</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Empty</span><span class="hljs-params">(DLinkList L)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L-&gt;next == L)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判断表尾结点-1"><a href="#判断表尾结点-1" class="headerlink" title="判断表尾结点"></a>判断表尾结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断结点p是否是表尾结点</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isTail</span><span class="hljs-params">(DLinkList L)</span>&#123;<br>    <span class="hljs-keyword">if</span>(L-&gt;next == L)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入-4"><a href="#插入-4" class="headerlink" title="插入"></a>插入</h4><p>循环双链表的插入、删除算法与双链表几乎一样，不同的是如果在表尾进行，那么要让双链表继续<strong>保持循环的性质</strong>，即<strong>让尾结点的next域指向头结点，同时让头结点的prior域指向尾结点</strong>。</p><p><code>注</code>：p-&gt;next-&gt;prior &#x3D; s; 循环时不判断</p><p><code>时间复杂度</code>&#x3D;O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将x插入到循环链表L中*p结点的下一个结点</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(DNode *p, <span class="hljs-type">int</span> x)</span>&#123;<br>    DNode *s = (DNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DNode));<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>||s==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s-&gt;data = x;<br>    s-&gt;next = p-&gt;next;  <span class="hljs-comment">//1</span><br>    p-&gt;next-&gt;prior = s; <span class="hljs-comment">//2</span><br>    s-&gt;prior = p;  <span class="hljs-comment">//3</span><br>    p-&gt;next = s; <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//在循环链表L中*p结点后插入s结点</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(DNode *p, DNode *s)</span>&#123;<br>    s-&gt;next = p-&gt;next;  <span class="hljs-comment">//1</span><br>    p-&gt;next-&gt;prior = s; <span class="hljs-comment">//2</span><br>    s-&gt;prior = p;  <span class="hljs-comment">//3</span><br>    p-&gt;next = s; <span class="hljs-comment">//4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><p><code>注</code>：p-&gt;next-&gt;prior &#x3D; s; 循环时不判断</p><h5 id="按位序删除-2"><a href="#按位序删除-2" class="headerlink" title="按位序删除"></a>按位序删除</h5><p><code>时间复杂度</code>&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除操作:将循环链表中的第i个结点删除</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">(DLinkList &amp;L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;Length(L)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    DNode *p = GetElem(L,i<span class="hljs-number">-1</span>);<br>    DNode *q = p-&gt;next;<br>    p-&gt;next = q-&gt;next; <span class="hljs-comment">//1</span><br>    q-&gt;next-&gt;prior = p; <span class="hljs-comment">//2</span><br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="指定结点的删除-2"><a href="#指定结点的删除-2" class="headerlink" title="指定结点的删除"></a>指定结点的删除</h5><p><code>时间复杂度</code>&#x3D;O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除操作:删除循环链表中的p结点的后继结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">DeleteNextNode</span><span class="hljs-params">(DNode *p)</span>&#123;<br>    DNode *q = p-&gt;next;<br>    p-&gt;next = q-&gt;next; <span class="hljs-comment">//1</span><br>    q-&gt;next-&gt;prior = p; <span class="hljs-comment">//2</span><br>    <span class="hljs-built_in">free</span>(q);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找-与单双链表完全一样"><a href="#查找-与单双链表完全一样" class="headerlink" title="查找(与单双链表完全一样)"></a>查找(与单双链表完全一样)</h4><h5 id="按位查找-4"><a href="#按位查找-4" class="headerlink" title="按位查找"></a>按位查找</h5><p><code>平均时间复杂度</code>&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按位查找：查找在循环链表L中第i个位置的结点</span><br>DNode *<span class="hljs-title function_">GetElem</span><span class="hljs-params">(DLinkList L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    DNode *p = L;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;<br>        p = p-&gt;next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p; <span class="hljs-comment">//如果i大于表长，p=NULL,直接返回p即可</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="按值查找-4"><a href="#按值查找-4" class="headerlink" title="按值查找"></a>按值查找</h5><p><code>平均时间复杂度</code>&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按值查找：查找e在L中的位置</span><br>DNode *<span class="hljs-title function_">LocateElem</span><span class="hljs-params">(DLinkList L, <span class="hljs-type">int</span> e)</span>&#123;<br>    DNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求表长、遍历、销毁"><a href="#求表长、遍历、销毁" class="headerlink" title="求表长、遍历、销毁"></a>求表长、遍历、销毁</h4><p>与单双链表一样</p><!----------------------------------------------------------------------------------><h2 id="静态链表——-Static-Linked-List"><a href="#静态链表——-Static-Linked-List" class="headerlink" title="静态链表—— Static Linked List"></a>静态链表—— Static Linked List</h2><h3 id="一、静态链表的定义"><a href="#一、静态链表的定义" class="headerlink" title="一、静态链表的定义"></a>一、静态链表的定义</h3><p><code>静态链表</code>借助<code>数组</code>来描述线性表的链式存储结构，结点也有<code>数据域data</code>和<code>指针域next</code>，这里的指针是结点的<code>相对地址（数组下标）</code>，又称<code>游标</code>。和顺序表一样，静态链表也需要预先分配一块连续的内存空间。</p><p><img src="https://img-blog.csdnimg.cn/20210418162136494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE2MjM2MQ==,size_16,color_FFFFFF,t_70" alt="静态链表"></p><h3 id="二、静态链表的特点"><a href="#二、静态链表的特点" class="headerlink" title="二、静态链表的特点"></a>二、静态链表的特点</h3><p>顺序表：逻辑上连续，物理上连续</p><p>静态链表：逻辑上离散，物理上连续</p><p>单双链表：逻辑上离散，物理上离散</p><p>静态链表比顺序表好。比单双链表差</p><p><code>优点</code>：增加、删除操作不需要移动大量元素</p><p><code>缺点</code>：①不能随机存取。只能从头结点遍历找</p><p>​               ②容量不可变</p><h3 id="三、静态链表上的操作"><a href="#三、静态链表上的操作" class="headerlink" title="三、静态链表上的操作"></a>三、静态链表上的操作</h3><h4 id="静态链表的类型描述"><a href="#静态链表的类型描述" class="headerlink" title="静态链表的类型描述"></a>静态链表的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50  <span class="hljs-comment">//静态链表的最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SLinkList</span>&#123;</span><br>ElemType data;  <span class="hljs-comment">//数据元素</span><br><span class="hljs-type">int</span> next;  <span class="hljs-comment">//下一个元素的数组下标</span><br>&#125;SLinkList[MaxSize];<br></code></pre></td></tr></table></figure><h4 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h4><p>a[0]的next设为-1</p><p>其它的next设为-2</p><h4 id="判空-2"><a href="#判空-2" class="headerlink" title="判空"></a>判空</h4><p>它的next为-2</p><p>则此结点为空</p><h4 id="插入-5"><a href="#插入-5" class="headerlink" title="插入"></a>插入</h4><p>①找一个空的结点，存入数据</p><p>②从头结点出发找到位序为i-1的结点</p><p>③修改新结点的next</p><p>④修改i-1号结点的next</p><h4 id="删除-4"><a href="#删除-4" class="headerlink" title="删除"></a>删除</h4><p>②从头结点出发找到前驱结点</p><p>③修改前驱结点的next</p><p>④被删除结点的next设为-2</p><h4 id="查找-3"><a href="#查找-3" class="headerlink" title="查找"></a>查找</h4><p>从头结点出发挨个往后遍历结点</p><h4 id="求表长-3"><a href="#求表长-3" class="headerlink" title="求表长"></a>求表长</h4><p>从头结点出发挨个往后遍历结点</p><h4 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h4><p>从头结点出发挨个往后遍历结点</p><!----------------------------------------------------------------------------------><h2 id="栈——-Stack"><a href="#栈——-Stack" class="headerlink" title="栈—— Stack"></a>栈—— Stack</h2><h3 id="一、栈的定义"><a href="#一、栈的定义" class="headerlink" title="一、栈的定义"></a>一、栈的定义</h3><p><code>栈</code>是线性表结构的一种，但是栈结构的插入与删除操作都只能从同一端进行，所以栈结构是一种受限制的线性表结构，数据的插入与删除符合LIFO的原则（也就是<code>后进先出</code>，<code>先进后出</code>）。</p><p><img src="https://img-blog.csdnimg.cn/20200317151355505.png#pic_center" alt="在这里插入图片描述"></p><h3 id="二、栈的基本操作"><a href="#二、栈的基本操作" class="headerlink" title="二、栈的基本操作"></a>二、栈的基本操作</h3><p><code>注</code>：参数代“&amp;”表示：方法运行完后，对参数修改的结果要<code>“带回来”</code></p><p>对数据的操作：创销，增删查改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">InitStack(&amp;S);     <span class="hljs-comment">//初始化表：构造一个空的栈S，分配内存空间</span><br>DestoryStack(&amp;S);  <span class="hljs-comment">//销毁操作：销毁栈，并释放栈S所占用的内存空间</span><br><br>Push(&amp;S,x);    <span class="hljs-comment">//进栈，若栈S未满，则将x加入使之成为新栈</span><br>Pop(&amp;S,&amp;x);    <span class="hljs-comment">//出栈，若栈S非空，则弹出栈顶元素，并用x返回</span><br><br>GetTop(S,&amp;x);  <span class="hljs-comment">//读栈顶元素，若栈S非空，则将x返回栈顶元素</span><br><br><span class="hljs-comment">//其它常用操作</span><br>StackEmpty(S);   <span class="hljs-comment">//判空操作</span><br></code></pre></td></tr></table></figure><h3 id="三、存储结构-1"><a href="#三、存储结构-1" class="headerlink" title="三、存储结构"></a>三、存储结构</h3><p><code>顺序存储</code>和<code>链式存储</code></p><h3 id="四、栈分类"><a href="#四、栈分类" class="headerlink" title="四、栈分类"></a>四、栈分类</h3><p>栈的顺序存储：顺序栈</p><p>栈的链式存储：链栈</p><!----------------------------------------------------------------------------------><h2 id="顺序栈——-Sequence-Stack"><a href="#顺序栈——-Sequence-Stack" class="headerlink" title="顺序栈—— Sequence Stack"></a>顺序栈—— Sequence Stack</h2><h3 id="一、顺序栈的定义"><a href="#一、顺序栈的定义" class="headerlink" title="一、顺序栈的定义"></a>一、顺序栈的定义</h3><p><code>顺序栈</code>：栈的<code>顺序存储</code>。</p><h3 id="二、顺序栈的实现方式"><a href="#二、顺序栈的实现方式" class="headerlink" title="二、顺序栈的实现方式"></a>二、顺序栈的实现方式</h3><p>实现方式：<code>静态分配</code>和<code>动态分配</code></p><h3 id="三、静态分配的顺序栈上的操作"><a href="#三、静态分配的顺序栈上的操作" class="headerlink" title="三、静态分配的顺序栈上的操作"></a>三、静态分配的顺序栈上的操作</h3><h4 id="顺序栈的类型描述"><a href="#顺序栈的类型描述" class="headerlink" title="顺序栈的类型描述"></a>顺序栈的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>Elemtype data[MaxSize];<span class="hljs-comment">//静态数组存放栈中元素</span><br><span class="hljs-type">int</span> top;               <span class="hljs-comment">//栈顶指针</span><br>&#125;SqStack;<br></code></pre></td></tr></table></figure><h4 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化一个栈</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span>&#123;<br>S.top = <span class="hljs-number">-1</span>;   <span class="hljs-comment">//初始化栈顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判栈空"><a href="#判栈空" class="headerlink" title="判栈空"></a>判栈空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack S)</span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//向栈中压入元素e</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack &amp;S,Elemtype e)</span>&#123;<br><span class="hljs-keyword">if</span>(S.Top == MaxSize<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>S.Top = S.Top + <span class="hljs-number">1</span>;  <span class="hljs-comment">//栈顶指针向上移动</span><br>    S.data[S.top] = e;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//栈顶元素出栈</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(Stack &amp;S,Elemtype &amp;e)</span>&#123;<br><span class="hljs-keyword">if</span>(S.Top == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e = S.data[S.Top];   <span class="hljs-comment">//x为栈顶元素，栈顶指针下移一个位置</span><br>S.Top = S.Top - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//获取栈顶元素e</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(Stack &amp;S,Elemtype &amp;e)</span>&#123;<br><span class="hljs-keyword">if</span>(S.Top==S.Base) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e = S.data[S.Top];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、动态分配的顺序栈上的操作"><a href="#四、动态分配的顺序栈上的操作" class="headerlink" title="四、动态分配的顺序栈上的操作"></a>四、动态分配的顺序栈上的操作</h3><h4 id="顺序栈的类型描述-1"><a href="#顺序栈的类型描述-1" class="headerlink" title="顺序栈的类型描述"></a>顺序栈的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>&#123;</span><br>Elemtype *Top;<span class="hljs-comment">//指向栈顶元素的上一个</span><br>Elemtype *Base;<span class="hljs-comment">//指向栈底</span><br><span class="hljs-type">int</span> stacksize;<span class="hljs-comment">//当前栈的空间大小</span><br>&#125;SqStack<br></code></pre></td></tr></table></figure><h4 id="初始化-5"><a href="#初始化-5" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化一个栈</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span>&#123;<br>S.Base=(Elemtype *)<span class="hljs-built_in">malloc</span>(MAXSIZE*<span class="hljs-keyword">sizeof</span>(Elemtype));<br><span class="hljs-keyword">if</span>(!S.Base) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>S.Top=S.Base;<br>S.stacksize=MAXSIZE;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判栈空-1"><a href="#判栈空-1" class="headerlink" title="判栈空"></a>判栈空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack S)</span>&#123;<br>    <span class="hljs-keyword">if</span>(S.Top == S.Base)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//向栈中压入元素e</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack &amp;S,Elemtype e)</span>&#123;<br><span class="hljs-keyword">if</span>(S.Top-S.Base==S.stacksize) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>*S.Top=e;<br>S.Top++;<span class="hljs-comment">//栈顶指针向上移动</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//栈顶元素出栈</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(Stack &amp;S,Eletype &amp;x)</span>&#123;<br><span class="hljs-keyword">if</span>(S.Top==S.Base) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>x=*--S.Top;<span class="hljs-comment">//x为栈顶元素，栈顶指针下移一个位置</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取栈顶元素-1"><a href="#获取栈顶元素-1" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//获取栈顶元素e</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(Stack &amp;S,Elemtype &amp;e)</span>&#123;<br><span class="hljs-keyword">if</span>(S.Top==S.Base) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e = *(S.Top<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><!----------------------------------------------------------------------------------><h2 id="链栈——-Linked-Stack"><a href="#链栈——-Linked-Stack" class="headerlink" title="链栈—— Linked Stack"></a>链栈—— Linked Stack</h2><h3 id="一、链栈的定义"><a href="#一、链栈的定义" class="headerlink" title="一、链栈的定义"></a>一、链栈的定义</h3><p><code>链栈</code>：栈的<code>链式存储</code>。</p><h3 id="二、链栈的实现方式"><a href="#二、链栈的实现方式" class="headerlink" title="二、链栈的实现方式"></a>二、链栈的实现方式</h3><p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般带头结点比不带头结点好</p><p>不带头结点：写操作代码麻烦，要区分第一个数据和后续数据的处理</p><p>带头结点：写操作代码方便，一般用带头结点，不明确的都是带头结点的</p><p><code>注</code>：这两种方式：只有类型描述一样，初始化不一样，</p><p>​           判空、入栈、出栈、取栈顶元素不一样，不带头节点是s，带头结点是s-&gt;next，因为链栈以<code>链头</code>为<code>栈顶</code></p><h3 id="三、不带头结点的链栈上的操作（与不带头结点的单链表一样）"><a href="#三、不带头结点的链栈上的操作（与不带头结点的单链表一样）" class="headerlink" title="三、不带头结点的链栈上的操作（与不带头结点的单链表一样）"></a>三、不带头结点的链栈上的操作（与不带头结点的单链表一样）</h3><p><code>链头</code>为<code>栈顶</code></p><h4 id="链栈的类型描述"><a href="#链栈的类型描述" class="headerlink" title="链栈的类型描述"></a>链栈的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>    <span class="hljs-comment">//定义单链表结点类型</span><br><span class="hljs-type">int</span> data;            <span class="hljs-comment">//数据域，可以是别的各种数据类型，本文统一用int类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//指针域</span><br>&#125;LNode, *LinkStack;<br></code></pre></td></tr></table></figure><h4 id="初始化-6"><a href="#初始化-6" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span>&#123;<br>    S = <span class="hljs-literal">NULL</span>;<br>    S-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判栈空-2"><a href="#判栈空-2" class="headerlink" title="判栈空"></a>判栈空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判空操作</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(LinkStack S)</span>&#123;<br>    <span class="hljs-keyword">if</span>(S == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入栈（与单链表插入一样）"><a href="#入栈（与单链表插入一样）" class="headerlink" title="入栈（与单链表插入一样）"></a>入栈（与单链表插入一样）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">push</span><span class="hljs-params">(LNode *s, <span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LNode *p = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    p-&gt;data = x;<br>    p-&gt;next = s;<br>    s = p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈（与单链表删除一样）"><a href="#出栈（与单链表删除一样）" class="headerlink" title="出栈（与单链表删除一样）"></a>出栈（与单链表删除一样）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">(LNode *s)</span>&#123;<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LNode *q = s;<br>    s-&gt;data = q-&gt;data<br>    s = q-&gt;next;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取栈顶元素（与单链表删除一样）"><a href="#获取栈顶元素（与单链表删除一样）" class="headerlink" title="获取栈顶元素（与单链表删除一样）"></a>获取栈顶元素（与单链表删除一样）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//获取栈顶元素e</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(LNode &amp;s,Elemtype &amp;e)</span>&#123;<br><span class="hljs-keyword">if</span>(s == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e = s-&gt;data;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、带头结点的链栈上的操作"><a href="#四、带头结点的链栈上的操作" class="headerlink" title="四、带头结点的链栈上的操作"></a>四、带头结点的链栈上的操作</h3><p>s都改为s-&gt;next，类型描述和初始化例外</p><h4 id="链栈的类型描述-1"><a href="#链栈的类型描述-1" class="headerlink" title="链栈的类型描述"></a>链栈的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>    <span class="hljs-comment">//定义单链表结点类型</span><br><span class="hljs-type">int</span> data;            <span class="hljs-comment">//数据域，可以是别的各种数据类型，本文统一用int类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//指针域</span><br>&#125;LNode, *LinkStack;<br></code></pre></td></tr></table></figure><h4 id="初始化-7"><a href="#初始化-7" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span>&#123;<br>    S = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    S-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判栈空-3"><a href="#判栈空-3" class="headerlink" title="判栈空"></a>判栈空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(LinkStack S)</span>&#123;<br>    <span class="hljs-keyword">if</span>(S-&gt;next == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入栈（与单链表插入一样）-1"><a href="#入栈（与单链表插入一样）-1" class="headerlink" title="入栈（与单链表插入一样）"></a>入栈（与单链表插入一样）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">push</span><span class="hljs-params">(LNode *s, <span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LNode *p = (LNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    p-&gt;data = x;<br>    p-&gt;next = s-&gt;next;<br>    s-&gt;next = p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈（与单链表删除一样）-1"><a href="#出栈（与单链表删除一样）-1" class="headerlink" title="出栈（与单链表删除一样）"></a>出栈（与单链表删除一样）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">(LNode *s)</span>&#123;<br>    <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LNode *q = s-&gt;next;<br>    s-&gt;data = q-&gt;data<br>    s-&gt;next = q-&gt;next;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取栈顶元素-2"><a href="#获取栈顶元素-2" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//获取栈顶元素e</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetTop</span><span class="hljs-params">(LNode &amp;s,Elemtype &amp;e)</span>&#123;<br><span class="hljs-keyword">if</span>(s-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e = s-&gt;next-&gt;data;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><!----------------------------------------------------------------------------------><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="一、表达式求值-中缀表达式求值"><a href="#一、表达式求值-中缀表达式求值" class="headerlink" title="一、表达式求值(中缀表达式求值)"></a>一、表达式求值(中缀表达式求值)</h3><p>三种表达式：<code>中缀表达式</code>、<code>后缀表达式</code>、<code>前缀表达式</code></p><p>中缀表达式：有界限符</p><p>后缀和前缀表达式：无界限符</p><p><code>注</code>：方法一和方法二是分开的，方法三是中缀转后缀和后缀计算同时进行，一般用方法三解决</p><h4 id="方法一：中缀表达式转后缀表达式，再用后缀表达式求值"><a href="#方法一：中缀表达式转后缀表达式，再用后缀表达式求值" class="headerlink" title="方法一：中缀表达式转后缀表达式，再用后缀表达式求值"></a>方法一：中缀表达式转后缀表达式，再用后缀表达式求值</h4><h5 id="1-中缀表达式转后缀表达式（用栈保存运算符）"><a href="#1-中缀表达式转后缀表达式（用栈保存运算符）" class="headerlink" title="1.中缀表达式转后缀表达式（用栈保存运算符）"></a>1.中缀表达式转后缀表达式（用<code>栈</code>保存<code>运算符</code>）</h5><p>中缀表达式<code>从左往右</code>扫描：</p><p>①遇到<code>操作数</code>，直接压入栈。</p><p>②遇到<code>界限符</code>，遇到“（”，直接压入栈；遇到“）”，依次弹出栈内运算符<code>从左往右</code>加入表达式，直到弹出“（”结束。</p><p>③遇到<code>运算符</code>，依次弹出比这个运算符优先级高的所有运算符，将此运算符压入栈。</p><h5 id="2-后缀表达式求值（用栈存运算结果）"><a href="#2-后缀表达式求值（用栈存运算结果）" class="headerlink" title="2.后缀表达式求值（用栈存运算结果）"></a>2.后缀表达式求值（用<code>栈</code>存<code>运算结果</code>）</h5><p>后缀表达式<code>从左往右</code>扫描：</p><p>①遇到<code>操作数</code>，直接压入栈。</p><p>②遇到<code>运算符</code>，弹出两个元素，执行相应运算，将运算结果压回栈顶</p><h4 id="方法二：中缀表达式转前缀表达式，再用前缀表达式求值"><a href="#方法二：中缀表达式转前缀表达式，再用前缀表达式求值" class="headerlink" title="方法二：中缀表达式转前缀表达式，再用前缀表达式求值"></a>方法二：中缀表达式转前缀表达式，再用前缀表达式求值</h4><h5 id="1-中缀表达式转前缀表达式（用栈保存运算符）"><a href="#1-中缀表达式转前缀表达式（用栈保存运算符）" class="headerlink" title="1.中缀表达式转前缀表达式（用栈保存运算符）"></a>1.中缀表达式转前缀表达式（用<code>栈</code>保存<code>运算符</code>）</h5><p>中缀表达式<code>从右往左</code>扫描：</p><p>①遇到<code>操作数</code>，直接压入栈。</p><p>②遇到<code>界限符</code>，遇到“（”，直接压入栈；遇到“）”，依次弹出栈内运算符<code>从右往左</code>加入表达式，直到弹出“（”结束。</p><p>③遇到<code>运算符</code>，依次弹出比这个运算符优先级高的所有运算符，将此运算符压入栈。</p><h5 id="2-前缀表达式求值（用栈存运算结果）"><a href="#2-前缀表达式求值（用栈存运算结果）" class="headerlink" title="2.前缀表达式求值（用栈存运算结果）"></a>2.前缀表达式求值（用<code>栈</code>存<code>运算结果</code>）</h5><p>前缀表达式<code>从右往左</code>扫描：</p><p>①遇到<code>操作数</code>，直接压入栈。</p><p>②遇到<code>运算符</code>，弹出两个元素，执行相应运算，将运算结果压回栈顶</p><h4 id="方法三：中缀转后缀和后缀计算同时进行-两个栈"><a href="#方法三：中缀转后缀和后缀计算同时进行-两个栈" class="headerlink" title="方法三：中缀转后缀和后缀计算同时进行(两个栈)"></a>方法三：中缀转后缀和后缀计算同时进行(两个栈)</h4><p>用<code>两个栈</code>：分别存<code>操作数</code>和<code>运算符</code></p><p>①遇到<code>操作数</code>，直接压入操作数栈。</p><p>②遇到<code>运算符</code>或<code>界限符</code>，按“中缀转后缀”的逻辑压入运算符栈，每当弹出一个运算符时，相应地弹出两个操作数，执行相应运算，将运算结果压回操作数栈</p><h3 id="二、递归"><a href="#二、递归" class="headerlink" title="二、递归"></a>二、递归</h3><p>递归的背后是栈的应用</p><!----------------------------------------------------------------------------------><h2 id="队列——-Queue"><a href="#队列——-Queue" class="headerlink" title="队列—— Queue"></a>队列—— Queue</h2><h3 id="一、队列的定义"><a href="#一、队列的定义" class="headerlink" title="一、队列的定义"></a>一、队列的定义</h3><p><code>队列</code>是只允许在一端进行插入，在另一端进行删除的线性表（<code>先进先出</code>，<code>后进后出</code>）</p><p><img src="http://c.biancheng.net/cpp/uploads/allimg/140713/1-140G31P93Y96.jpg" alt="img"></p><h3 id="二、队列的基本操作"><a href="#二、队列的基本操作" class="headerlink" title="二、队列的基本操作"></a>二、队列的基本操作</h3><p><code>注</code>：参数代“&amp;”表示：方法运行完后，对参数修改的结果要<code>“带回来”</code></p><p>对数据的操作：创销，增删查改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">InitQueue(&amp;Q);     <span class="hljs-comment">//初始化队列：构造一个空队列Q，分配内存空间</span><br>DestoryQueue(&amp;Q);  <span class="hljs-comment">//销毁操作：销毁队列，并释放队列Q所占用的内存空间</span><br><br>EnQueue(&amp;Q,x);    <span class="hljs-comment">//入队，若队列Q未满，则将x加入使之成为新的队尾</span><br>DeQueue(&amp;Q,&amp;x);    <span class="hljs-comment">//出队，若队列Q非空，则删除队头元素，并用x返回</span><br><br>GetHead(Q,&amp;x);  <span class="hljs-comment">//读队头元素，若队列Q非空，则将x返回队头元素</span><br><br><span class="hljs-comment">//其它常用操作</span><br>QueueEmpty(Q);   <span class="hljs-comment">//判空操作</span><br></code></pre></td></tr></table></figure><h3 id="三、存储结构-2"><a href="#三、存储结构-2" class="headerlink" title="三、存储结构"></a>三、存储结构</h3><p><code>顺序存储</code>和<code>链式存储</code></p><h3 id="四、队列分类"><a href="#四、队列分类" class="headerlink" title="四、队列分类"></a>四、队列分类</h3><p>队列的顺序存储：顺序队列</p><p>队列的链式存储：链式队列</p><!----------------------------------------------------------------------------------><h2 id="顺序队列——-Sequence-Queue"><a href="#顺序队列——-Sequence-Queue" class="headerlink" title="顺序队列—— Sequence Queue"></a>顺序队列—— Sequence Queue</h2><h3 id="一、顺序队列的定义"><a href="#一、顺序队列的定义" class="headerlink" title="一、顺序队列的定义"></a>一、顺序队列的定义</h3><p><code>顺序队列</code>：队列的<code>顺序存储</code>。</p><h3 id="二、顺序队列的实现方式"><a href="#二、顺序队列的实现方式" class="headerlink" title="二、顺序队列的实现方式"></a>二、顺序队列的实现方式</h3><p>实现方式：<code>静态分配</code>和<code>动态分配</code></p><p><code>注</code>：这两种方式：只是类型描述和初始化不一样，判空、入队、出队、取队头操作都一样</p><h3 id="三、顺序队列上的操作"><a href="#三、顺序队列上的操作" class="headerlink" title="三、顺序队列上的操作"></a>三、顺序队列上的操作</h3><p>以<code>循环队列</code>为主</p><h4 id="静态分配的顺序队列：类型描述和初始化"><a href="#静态分配的顺序队列：类型描述和初始化" class="headerlink" title="静态分配的顺序队列：类型描述和初始化"></a>静态分配的顺序队列：类型描述和初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>Elemtype data[MaxSize];<span class="hljs-comment">//静态数组存放队列中元素</span><br>Elemtype front,rear;        <span class="hljs-comment">//队列顶指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化一个队列</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqQueue &amp;Q)</span>&#123;<br>Q.rear = Q.front = <span class="hljs-number">0</span>;   <span class="hljs-comment">//初始化队列顶指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态分配的顺序队列：类型描述和初始化"><a href="#动态分配的顺序队列：类型描述和初始化" class="headerlink" title="动态分配的顺序队列：类型描述和初始化"></a>动态分配的顺序队列：类型描述和初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>Elemtype *base;             <span class="hljs-comment">//静态数组存放队列中元素</span><br>Elemtype front,rear;        <span class="hljs-comment">//队列顶指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化一个队列</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span>&#123;<br>Q.base=(Elemtype *)<span class="hljs-built_in">malloc</span>(MAXQSIZE*<span class="hljs-keyword">sizeof</span>(Elemtype));<br><span class="hljs-keyword">if</span>(!Q.Base) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>Q.front = Q.rear = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判队列空"><a href="#判队列空" class="headerlink" title="判队列空"></a>判队列空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判空</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack S)</span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front)&#123;  <span class="hljs-comment">//队列已空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入队（循环队列）"><a href="#入队（循环队列）" class="headerlink" title="入队（循环队列）"></a>入队（循环队列）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//入队</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,Elemtype e)</span>&#123;<br><span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MAXSIZE == Q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//队列已满</span><br>Q.data[Q.rear] = e;<span class="hljs-comment">//e为队尾元素</span><br>    Q.rear = (Q.rear + <span class="hljs-number">1</span>)%MaxSize;  <span class="hljs-comment">//队尾指针后移</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出队（循环队列）"><a href="#出队（循环队列）" class="headerlink" title="出队（循环队列）"></a>出队（循环队列）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//出队</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,Elemtype &amp;e)</span>&#123;<br><span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e = Q.data[Q.front];            <span class="hljs-comment">//e为队头元素</span><br>    Q.front=(Q.front+<span class="hljs-number">1</span>)%MAXQSIZE;<span class="hljs-comment">//队头指针后移</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取队头元素"><a href="#获取队头元素" class="headerlink" title="获取队头元素"></a>获取队头元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//获取队头元素</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetHead</span><span class="hljs-params">(SqQueue &amp;Q,Elemtype &amp;e)</span>&#123;<br><span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e = Q.data[Q.front];   <span class="hljs-comment">//e为队列顶元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列已空-已满"><a href="#队列已空-已满" class="headerlink" title="队列已空&#x2F;已满"></a>队列已空&#x2F;已满</h4><p>方案一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>Elemtype data[MaxSize];<span class="hljs-comment">//静态数组存放队列中元素</span><br><span class="hljs-type">int</span> front,rear;        <span class="hljs-comment">//队列顶指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p>已空：Q.rear &#x3D;&#x3D; Q.front已满：(Q.rear+1)%MAXSIZE &#x3D;&#x3D; Q.front</p><p>方案二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>Elemtype data[MaxSize];<span class="hljs-comment">//静态数组存放队列中元素</span><br><span class="hljs-type">int</span> front,rear;        <span class="hljs-comment">//队列顶指针</span><br>    <span class="hljs-type">int</span> size;              <span class="hljs-comment">//队列当前长度</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p>已空：size &#x3D;&#x3D; 0已满：size &#x3D;&#x3D; MAXSIZE</p><p>方案三：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>Elemtype data[MaxSize];<span class="hljs-comment">//静态数组存放队列中元素</span><br><span class="hljs-type">int</span> front,rear;        <span class="hljs-comment">//队列顶指针</span><br>    <span class="hljs-type">int</span> tag;              <span class="hljs-comment">//记录最近是删除还是插入，0是删除，1是插入</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p>已空：Q.rear &#x3D;&#x3D; Q.front &amp;&amp; tag &#x3D; 0已满：Q.rear &#x3D;&#x3D; Q.front &amp;&amp; tag &#x3D; 1</p><h4 id="元素的个数"><a href="#元素的个数" class="headerlink" title="元素的个数"></a>元素的个数</h4><p>(Q.rear+MAXSIZE-Q.front)%MAXSIZE &#x3D;&#x3D; Q.front</p><!----------------------------------------------------------------------------------><h2 id="链队列——-Linked-Queue"><a href="#链队列——-Linked-Queue" class="headerlink" title="链队列—— Linked Queue"></a>链队列—— Linked Queue</h2><h3 id="一、链队列的定义"><a href="#一、链队列的定义" class="headerlink" title="一、链队列的定义"></a>一、链队列的定义</h3><p><code>链队列</code>：队列的<code>链存储</code>。</p><h3 id="二、链队列的实现方式"><a href="#二、链队列的实现方式" class="headerlink" title="二、链队列的实现方式"></a>二、链队列的实现方式</h3><p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般带头结点比不带头结点好</p><p><code>注</code>：这两种方式：类型描述相同，初始化和判空不同</p><p>​   入队，不带头节点要对第一个特殊处理</p><p>​           出队，取队头元素不一样，不带头节点是Q.front，带头结点是Q.front-&gt;next，因为链队以<code>链头</code>为<code>队头</code></p><h3 id="三、不带头结点的链队列上的操作"><a href="#三、不带头结点的链队列上的操作" class="headerlink" title="三、不带头结点的链队列上的操作"></a>三、不带头结点的链队列上的操作</h3><h4 id="链队列的类型描述"><a href="#链队列的类型描述" class="headerlink" title="链队列的类型描述"></a>链队列的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>    <span class="hljs-comment">//定义单链表结点类型</span><br>ElemType data;            <span class="hljs-comment">//数据域，可以是别的各种数据类型，本文统一用int类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//指针域</span><br>&#125;LNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    LNode *front, *rear;<br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><h4 id="初始化-8"><a href="#初始化-8" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//初始化一个队列</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span>&#123;<br>    <span class="hljs-comment">//初始时，front, rear都指向NULL</span><br>Q.front = <span class="hljs-literal">NULL</span>;<br>    Q.rear = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判空-3"><a href="#判空-3" class="headerlink" title="判空"></a>判空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判空</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(LinkQueue S)</span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == <span class="hljs-literal">NULL</span>)&#123;  <span class="hljs-comment">//队列已空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//入队</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,Elemtype e)</span>&#123;<br>LNode *s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>s-&gt;data = e;  <span class="hljs-comment">//e为队尾元素</span><br>    s-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//对第一个特殊处理</span><br>    <span class="hljs-keyword">if</span>(Q.front == <span class="hljs-literal">NULL</span>)&#123;<br>        Q.front = s;<br>        Q.rear = s;<br>    &#125;<br>    Q.rear-&gt;next = s;     <span class="hljs-comment">//新结点插入到rear后</span><br>    Q.rear s;             <span class="hljs-comment">//队尾指针后移</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//出队</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,Elemtype &amp;e)</span>&#123;<br><span class="hljs-keyword">if</span>(Q.rear == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>LNode *p = Q.front;<br>    e = p-&gt;data;          <span class="hljs-comment">//e为队头元素</span><br>    Q.front = p-&gt;next;  <span class="hljs-comment">//队头指针后移</span><br>    <span class="hljs-keyword">if</span>(Q.rear == p)&#123;      <span class="hljs-comment">//最后一个结点出队</span><br>        Q.front = <span class="hljs-literal">NULL</span>;<br>        Q.rear = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取队头元素-1"><a href="#获取队头元素-1" class="headerlink" title="获取队头元素"></a>获取队头元素</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//获取队头元素</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetHead</span><span class="hljs-params">(SqQueue &amp;Q,Elemtype &amp;e)</span>&#123;<br><span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>e = Q.data[Q.front];   <span class="hljs-comment">//e为队列顶元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、带头结点的链队列上的操作"><a href="#四、带头结点的链队列上的操作" class="headerlink" title="四、带头结点的链队列上的操作"></a>四、带头结点的链队列上的操作</h3><h4 id="链队列的类型描述-1"><a href="#链队列的类型描述-1" class="headerlink" title="链队列的类型描述"></a>链队列的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>    <span class="hljs-comment">//定义单链表结点类型</span><br>ElemType data;            <span class="hljs-comment">//数据域，可以是别的各种数据类型，本文统一用int类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//指针域</span><br>&#125;LNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    LNode *front, *rear;<br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><h4 id="初始化-9"><a href="#初始化-9" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化一个队列</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span>&#123;<br>    <span class="hljs-comment">////初始时，front, rear都指向头结点</span><br>Q.front = Q.rear = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>Q.front = Q.rear = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判空-4"><a href="#判空-4" class="headerlink" title="判空"></a>判空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判空</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack S)</span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front)&#123;  <span class="hljs-comment">//队列已空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//或</span><br><span class="hljs-comment">//判空</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack S)</span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front-&gt;next == <span class="hljs-literal">NULL</span>)&#123;  <span class="hljs-comment">//队列已空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="入队（循环队列）-1"><a href="#入队（循环队列）-1" class="headerlink" title="入队（循环队列）"></a>入队（循环队列）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//入队</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,Elemtype e)</span>&#123;<br>LNode *s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>s-&gt;data = e;  <span class="hljs-comment">//e为队尾元素</span><br>    s-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Q-&gt;rear-&gt;next = s;    <span class="hljs-comment">//新结点插入到rear后</span><br>    Q.rear s;             <span class="hljs-comment">//队尾指针后移</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//出队</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,Elemtype &amp;e)</span>&#123;<br><span class="hljs-keyword">if</span>(Q.rear == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>LNode *p = Q.front-&gt;next;<br>    e = p-&gt;data;          <span class="hljs-comment">//e为队头元素</span><br>    Q.front-&gt;next = p-&gt;next;  <span class="hljs-comment">//队头指针后移</span><br>    <span class="hljs-keyword">if</span>(Q.rear == p)&#123;      <span class="hljs-comment">//最后一个结点出队</span><br>        Q.front = Q.rear;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、队列已满"><a href="#五、队列已满" class="headerlink" title="五、队列已满"></a>五、队列已满</h3><p>链队一般不会队满</p><!----------------------------------------------------------------------------------><h2 id="双端队列——-Double-ended-Queue"><a href="#双端队列——-Double-ended-Queue" class="headerlink" title="双端队列—— Double-ended Queue"></a>双端队列—— Double-ended Queue</h2><h3 id="一、双端队列的定义"><a href="#一、双端队列的定义" class="headerlink" title="一、双端队列的定义"></a>一、双端队列的定义</h3><p><code>线性表</code>：任何位置插入删除</p><p>栈、队列、双端队列都是只能两端插入删除的线性表</p><p><code>栈</code>：一端插入删除</p><p><code>共享栈</code>：栈的变种，两端为栈底，中间为栈顶，只能两端向中间插入删除</p><p><code>队列</code>：一端插入，另一端删除</p><p><code>双端队列</code>：两端都可插入删除</p><p><code>输入受限的双端队列</code>：一端插入，两端删除</p><p><code>输出受限的双端队列</code>：两端插入，一端删除</p><!----------------------------------------------------------------------------------><h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><h3 id="一、树的层次遍历"><a href="#一、树的层次遍历" class="headerlink" title="一、树的层次遍历"></a>一、树的层次遍历</h3><h3 id="二、图的广度优先遍历"><a href="#二、图的广度优先遍历" class="headerlink" title="二、图的广度优先遍历"></a>二、图的广度优先遍历</h3><h3 id="三、操作系统中的应用"><a href="#三、操作系统中的应用" class="headerlink" title="三、操作系统中的应用"></a>三、操作系统中的应用</h3><p>多个进程争抢有限的系统资源时，采用<code>先来先服务算法(FCFS)</code></p><p>例子：CPU资源分配；打印数据缓冲区</p><!----------------------------------------------------------------------------------><h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><h3 id="一、数组的存储结构"><a href="#一、数组的存储结构" class="headerlink" title="一、数组的存储结构"></a>一、数组的存储结构</h3><p><code>一维数组</code>：$$a[N]$$<br>逻辑上连续存放，物理上（内存中）也连续存放<br>数组元素$$a[i]$$的<code>物理地址=LOC+i*sizeof(ElemType)</code></p><p><code>二维数组</code>：$$a[N][M]$$<br>逻辑上是n行n列的矩阵，物理上（内存中）是<code>行优先存储</code>和<code>列优先存储</code>的连续存放<br><code>行优先存储</code>：数组元素$$a[i][j]$$的<code>物理地址=LOC+(i*N+j)*sizeof(ElemType)</code><br><code>列优先存储</code>：数组元素$$a[i][j]$$的<code>物理地址=LOC+(J*M+i)*sizeof(ElemType)</code></p><p>普通矩阵的存储可用二维数组存储。</p><h3 id="二、特殊矩阵的存储"><a href="#二、特殊矩阵的存储" class="headerlink" title="二、特殊矩阵的存储"></a>二、特殊矩阵的存储</h3><p>①对称矩阵<br>②三角矩阵<br>③三对角矩阵<br>④稀疏矩阵</p><h4 id="2-1对称矩阵的压缩存储"><a href="#2-1对称矩阵的压缩存储" class="headerlink" title="2.1对称矩阵的压缩存储"></a>2.1对称矩阵的压缩存储</h4><p><code>对称矩阵</code>：$$a_{i,j}&#x3D;a_{j,i}$$<br>方法：一维数组$$a[N]$$只存主对角线+下三角区（或主对角线+上三角区）<br>存储数组的大小：$$N&#x3D;\frac{n(n+1)}{2}$$<br>数组下标范围：$$0$$ ~ $$\frac{n(n+1)}{2}-1$$<br><code>行优先存储</code>：数组下标：$$k&#x3D;\begin{cases} \frac{i(i-1)}{2}+j-1, \quad i \geq j(下三角区和主对角线元素)\ \frac{j(j-1)}{2}+i-1, \quad i&lt;j(上三角区元素a_{i,j}&#x3D;a_{j,i}) \end{cases}$$</p><h4 id="2-2三角矩阵的压缩存储"><a href="#2-2三角矩阵的压缩存储" class="headerlink" title="2.2三角矩阵的压缩存储"></a>2.2三角矩阵的压缩存储</h4><p>①<code>下三角矩阵</code>：除主对角线和下三角区，其余的元素都相等<br>方法：一维数组$$a[N]$$存主对角线+下三角区，在最后多加一个位置存常其余相等元素<br>存储数组的大小：$$N&#x3D;\frac{n(n+1)}{2}+1$$<br>数组下标范围：$$0$$ ~ $$\frac{n(n+1)}{2}$$<br><code>行优先存储</code>：数组下标：$$k&#x3D;\begin{cases} \frac{i(i-1)}{2}+j-1, \quad i \geq j(下三角区和主对角线元素)\ \frac{n(n+1)}{2}, \quad\quad\quad\quad i&lt;j(上三角区元素) \end{cases}$$</p><p>②<code>上三角矩阵</code>：除主对角线和上三角区，其余的元素都相等<br>方法：一维数组$$a[N]$$存主对角线+下三角区，在最后多加一个位置存常其余相等元素<br>存储数组的大小：$$N&#x3D;\frac{n(n+1)}{2}+1$$<br>数组下标范围：$$0$$ ~ $$\frac{n(n+1)}{2}$$<br><code>行优先存储</code>：数组下标：$$k&#x3D;\begin{cases} \frac{(i-1)(2n-i+2)}{2}+(j-i), \quad i \geq j(下三角区和主对角线元素)\ \frac{n(n+1)}{2}, \quad\quad\quad\quad\quad\quad\quad~ i&lt;j(上三角区元素) \end{cases}$$</p><h4 id="2-3三对角矩阵的压缩存储"><a href="#2-3三对角矩阵的压缩存储" class="headerlink" title="2.3三对角矩阵的压缩存储"></a>2.3三对角矩阵的压缩存储</h4><p><code>三对角矩阵</code>，又称<code>带状矩阵</code>。<br>方法：一维数组$$a[N]$$存带状部分<br>存储数组的大小：$$N&#x3D;3n-3+1$$<br>数组下标范围：$$0$$ ~ $$3n-3$$<br><code>行优先存储</code>：<br><code>i和j计算数组下标k</code>：$$k&#x3D;2i+j-3$$<br><code>数组下标k计算i和j</code>：$$i&#x3D;\lceil (k+2)&#x2F;3 \rceil$$，$$j&#x3D;k-2i+3$$</p><h4 id="2-4稀疏矩阵的压缩存储"><a href="#2-4稀疏矩阵的压缩存储" class="headerlink" title="2.4稀疏矩阵的压缩存储"></a>2.4稀疏矩阵的压缩存储</h4><p><code>稀疏矩阵</code>：非零元素的个数远远少于矩阵元素的个数。</p><p><code>方法一：顺序存储——三元组&lt;行，列，值&gt;</code>，注：行列从1开始</p><table><thead><tr><th>i（行）</th><th>j（列）</th><th>v（值）</th></tr></thead><tbody><tr><td>1</td><td>3</td><td>4</td></tr><tr><td>1</td><td>6</td><td>5</td></tr><tr><td>2</td><td>2</td><td>3</td></tr></tbody></table><p><code>方法二：链式存储——十字链表法</code></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637932175187.png" alt="1637932175187"></p><!----------------------------------------------------------------------------------><h2 id="串，即字符串——String"><a href="#串，即字符串——String" class="headerlink" title="串，即字符串——String"></a>串，即字符串——String</h2><h3 id="一、串的定义"><a href="#一、串的定义" class="headerlink" title="一、串的定义"></a>一、串的定义</h3><p><code>串</code>是一种特殊的<code>线性表</code>，串的<code>数据对象</code>限定为<code>字符集</code></p><h3 id="二、串的基本操作"><a href="#二、串的基本操作" class="headerlink" title="二、串的基本操作"></a>二、串的基本操作</h3><p><code>注</code>：参数代“&amp;”表示：方法运行完后，对参数修改的结果要<code>“带回来”</code></p><p>对数据的操作：创销，增删查改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">StrAssign(&amp;τ chars);<span class="hljs-comment">//赋值操作。把串T赋值为chars</span><br>StrCopy(&amp;TS);       <span class="hljs-comment">//复制操作。由串S复制得到串T。</span><br>StrEmpty(S);        <span class="hljs-comment">//判空操作。若S为空串,则返回TRUE,否则返回 FALSE。</span><br>StrEngth(S);        <span class="hljs-comment">//求串长。返回串S的元素个数</span><br>ClearString(&amp;S);    <span class="hljs-comment">//清空操作。将S清为空串。</span><br>Destroystring(&amp;S);  <span class="hljs-comment">//销毁串。将串S销毁(回收存储空间)。</span><br>Concat(&amp;TS1, S2);   <span class="hljs-comment">//串联接。用T返回由S1和S2联接而成的新串</span><br>SubString(&amp;sub,S, pos, len);<span class="hljs-comment">//求子串。用Sub返回串S的第pos个字符起长度为|en的子串。</span><br>ndex(S, T);         <span class="hljs-comment">//定位操作。若主串S中存在与串T值相同的子串,则返回它在主串S中第一次出现的位置;否则函数值为0。</span><br>StrCompare(S,T);    <span class="hljs-comment">//比较操作。若S&gt;T,则返回值&gt;0;若S=T,则返回值=0;若S&lt;T,则返回值&lt;0。</span><br></code></pre></td></tr></table></figure><h3 id="三、存储结构-3"><a href="#三、存储结构-3" class="headerlink" title="三、存储结构"></a>三、存储结构</h3><p><code>顺序存储</code>和<code>链式存储</code></p><!----------------------------------------------------------------------------------><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="一、串的存储结构"><a href="#一、串的存储结构" class="headerlink" title="一、串的存储结构"></a>一、串的存储结构</h3><p><code>顺序存储</code>和<code>链式存储</code></p><h3 id="二、串的顺序存储的实现方式"><a href="#二、串的顺序存储的实现方式" class="headerlink" title="二、串的顺序存储的实现方式"></a>二、串的顺序存储的实现方式</h3><p>实现方式：<code>静态分配</code>和<code>动态分配</code>，一般用动态分配</p><h4 id="串的类型描述："><a href="#串的类型描述：" class="headerlink" title="串的类型描述："></a>串的类型描述：</h4><h5 id="静态分配：SString"><a href="#静态分配：SString" class="headerlink" title="静态分配：SString"></a>静态分配：SString</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255; <span class="hljs-comment">//定义最大长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span> ch[MAXLEN];         <span class="hljs-comment">//“静态”的数组存数据，存字符</span><br>    <span class="hljs-type">int</span> length;              <span class="hljs-comment">//串的实际长度</span><br>&#125;SString;<br></code></pre></td></tr></table></figure><h5 id="动态分配：HString"><a href="#动态分配：HString" class="headerlink" title="动态分配：HString"></a>动态分配：HString</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span> *ch;                <span class="hljs-comment">//指向“动态”分配的串的基地址</span><br>    <span class="hljs-type">int</span> length;              <span class="hljs-comment">//顺序表的当前长度</span><br>&#125;HString;<br></code></pre></td></tr></table></figure><h4 id="静态分配的顺序存储的串的优缺点"><a href="#静态分配的顺序存储的串的优缺点" class="headerlink" title="静态分配的顺序存储的串的优缺点"></a>静态分配的顺序存储的串的优缺点</h4><p><code>缺点</code>：串的顺序存储的表长确定后无法修改，存满了就存不了了</p><h4 id="动态分配的顺序表的优缺点：-1"><a href="#动态分配的顺序表的优缺点：-1" class="headerlink" title="动态分配的顺序表的优缺点："></a>动态分配的顺序表的优缺点：</h4><p><code>优点</code>：可以动态增加长度</p><p><code>缺点</code>：动态增加长度中的迁移工作时间开销大</p><h3 id="三、串的链式存储的实现方式"><a href="#三、串的链式存储的实现方式" class="headerlink" title="三、串的链式存储的实现方式"></a>三、串的链式存储的实现方式</h3><p>实现方式：<code>不带头结点</code>和<code>带头结点</code>，一般用带头结点</p><p><code>不带头结点</code>和<code>带头结点</code>的类型描述相同，初始化和判空不同</p><h4 id="串的类型描述：-1"><a href="#串的类型描述：-1" class="headerlink" title="串的类型描述："></a>串的类型描述：</h4><p>分为：<code>单个分配</code>和<code>堆分配</code>，一般用堆分配</p><p>单个分配存储密度低，堆分配存储密度高</p><h5 id="单个分配："><a href="#单个分配：" class="headerlink" title="单个分配："></a>单个分配：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StringNode</span>&#123;</span><br>    <span class="hljs-type">char</span> ch;                  <span class="hljs-comment">//每个结点存1个字符</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StringNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StringNode, *String;<br></code></pre></td></tr></table></figure><h5 id="堆分配："><a href="#堆分配：" class="headerlink" title="堆分配："></a>堆分配：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StringNode</span>&#123;</span><br>    <span class="hljs-type">char</span> ch[<span class="hljs-number">4</span>];                  <span class="hljs-comment">//每个结点存4个字符</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StringNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StringNode, *String;<br></code></pre></td></tr></table></figure><h3 id="四、串的上的操作"><a href="#四、串的上的操作" class="headerlink" title="四、串的上的操作"></a>四、串的上的操作</h3><p>以静态分配的顺序串为主</p><h4 id="求子串"><a href="#求子串" class="headerlink" title="求子串"></a>求子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求子串</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">SubString</span><span class="hljs-params">(SString &amp;Sub, SString S, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> len)</span>&#123;<br>    <span class="hljs-comment">//子串范围越界</span><br>    <span class="hljs-keyword">if</span>(pos+len<span class="hljs-number">-1</span> &gt;S.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos; i&lt;pos+len; i++)&#123;<br>        Sub.ch[i-pos+<span class="hljs-number">1</span>] =S.ch[i];<br>    &#125;<br>    Sub.length = len;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//字符串比较操作。若S&gt;T,则返回值&gt;0;若S=T,则返回值=0;若S&lt;T,则返回值&lt;0。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">StrCompare</span><span class="hljs-params">(SString S, SString T)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;S.length &amp;&amp; T.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(S.ch[i]!=T.ch[i]) <span class="hljs-keyword">return</span> S.ch[i]-T[i];<br>    &#125;<br>    <span class="hljs-comment">//扫描过所有字符都相等，则长度更长的串更大</span><br>    <span class="hljs-keyword">return</span> S.length-T.length;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="定位操作"><a href="#定位操作" class="headerlink" title="定位操作"></a>定位操作</h4><p>方法：在S中依次按顺序取m长子串，判断是否与T相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定位操作</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index</span><span class="hljs-params">(SString S,SString T)</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, n = StrLength(S), m = StrLength(T);<br>    SString sub;<br>    <span class="hljs-keyword">while</span>(i &lt; n-m+<span class="hljs-number">1</span>)&#123;<br>        SubString(sub, S, i, m);<br>        <span class="hljs-keyword">if</span>(StrCompare(sub, T) != <span class="hljs-number">0</span>) ++i;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回子串在主串中的位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;          <span class="hljs-comment">//S中不存在与T相同的子串</span><br>&#125;<br></code></pre></td></tr></table></figure><!----------------------------------------------------------------------------------><h2 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h2><p><code>字符串模式匹配</code>：在<code>主串</code>中找到与<code>模式串</code>相同的子串,并返回其所在位置。</p><p><code>子串</code>：一定能在主串中找到的串</p><p><code>模式串</code>：不一定能在主串中找到的串</p><p>方法：<code>朴素模式匹配算法</code>和<code>KMP算法</code></p><h3 id="一、朴素模式匹配算法"><a href="#一、朴素模式匹配算法" class="headerlink" title="一、朴素模式匹配算法"></a>一、朴素模式匹配算法</h3><h4 id="1-用串的定位操作："><a href="#1-用串的定位操作：" class="headerlink" title="1.用串的定位操作："></a>1.用串的定位操作：</h4><p>方法：在S中依次按顺序取m长子串，判断是否与T相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定位操作</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index</span><span class="hljs-params">(SString S,SString T)</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, n = StrLength(S), m = StrLength(T);<br>    SString sub;<br>    <span class="hljs-keyword">while</span>(i &lt; n-m+<span class="hljs-number">1</span>)&#123;<br>        SubString(sub, S, i, m);<br>        <span class="hljs-keyword">if</span>(StrCompare(sub, T) != <span class="hljs-number">0</span>) ++i;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回子串在主串中的位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;          <span class="hljs-comment">//S中不存在与T相同的子串</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-双指针算法"><a href="#2-双指针算法" class="headerlink" title="2.双指针算法"></a>2.双指针算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Index</span><span class="hljs-params">(SString S, SString T)</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;  <span class="hljs-comment">//跳出循环情况：j&gt;T.length,匹配成功</span><br>        <span class="hljs-keyword">if</span>(S.ch[i]==T.ch[i])&#123;             <span class="hljs-comment">//i&gt;S.length,匹配失败</span><br>            ++i; ++j;          <span class="hljs-comment">//继续比较后面的字符</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;   <span class="hljs-comment">//匹配失败，指针i、j都后退，匹配下一个</span><br>            i = i-j+<span class="hljs-number">2</span>;<br>            j = <span class="hljs-number">1</span>;             <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt; T.length)&#123;          <span class="hljs-comment">//j&gt;T.length,匹配成功</span><br>        <span class="hljs-keyword">return</span> i-T.length;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="朴素模式匹配算法的时间复杂度："><a href="#朴素模式匹配算法的时间复杂度：" class="headerlink" title="朴素模式匹配算法的时间复杂度："></a>朴素模式匹配算法的时间复杂度：</h4><p>设主串长度为n，模式串长度为m，则</p><p>最好情况：每次匹配第一个字符就匹配失败，直到最后才匹配成功，循环n次，<code>最好时间复杂度</code>&#x3D;O(n)</p><p>最坏情况：到最后也没找到，主串移动n个元素，模式串移动m个元素，<code>最坏时间复杂度</code>&#x3D;O(mn)</p><h3 id="二、KMP算法"><a href="#二、KMP算法" class="headerlink" title="二、KMP算法"></a>二、KMP算法</h3><p>精髓：利用好已经匹配过的模式串信息，建立一个next数组，表示j的回溯</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Index</span><span class="hljs-params">(SString S, SString T)</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;  <span class="hljs-comment">//跳出循环情况：j&gt;T.length,匹配成功</span><br>        <span class="hljs-keyword">if</span>(S.ch[i]==T.ch[i])&#123;             <span class="hljs-comment">//i&gt;S.length,匹配失败</span><br>            ++i; ++j;          <span class="hljs-comment">//继续比较后面的字符</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;   <span class="hljs-comment">//匹配失败，指针i不变，j后退，匹配下一个</span><br>            j=next[j];            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt; T.length)&#123;          <span class="hljs-comment">//j&gt;T.length,匹配成功</span><br>        <span class="hljs-keyword">return</span> i-T.length;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="KMP算法的时间复杂度："><a href="#KMP算法的时间复杂度：" class="headerlink" title="KMP算法的时间复杂度："></a>KMP算法的时间复杂度：</h4><p>设主串长度为n，模式串长度为m，则</p><p>最好情况：每次匹配第一个字符就匹配失败，直到最后才匹配成功，循环n次，<code>最好时间复杂度</code>&#x3D;O(n)</p><p>最坏情况：到最后也没找到，主串移动n个元素，模式串移动m个元素，<code>最坏时间复杂度</code>&#x3D;O(m+n)</p><h4 id="next数组的建立"><a href="#next数组的建立" class="headerlink" title="next数组的建立"></a>next数组的建立</h4><p>P[0 ~ k-1] &#x3D;&#x3D; P[j-k ~ j-1]</p><p><img src="https://images0.cnblogs.com/blog/416010/201308/17084056-66930855432b4357bafbf8d6c76c1840.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//next数组的建立</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(String ps)</span>&#123;<br>    <span class="hljs-type">char</span>[] p = ps.toCharArray();<br>    <span class="hljs-type">int</span>[] next = new <span class="hljs-type">int</span>[p.length];<br>    next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (j &lt; p.length)&#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || p[j] == p[k]) &#123;<br>            next[++j] = ++k;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            k = next[k];<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><!----------------------------------------------------------------------------------><h2 id="树-——-Tree"><a href="#树-——-Tree" class="headerlink" title="树 —— Tree"></a>树 —— Tree</h2><h3 id="一、树的定义："><a href="#一、树的定义：" class="headerlink" title="一、树的定义："></a>一、树的定义：</h3><p><code>树</code>是η(n≥0)个结点的有限集合,n≡o时,称为空树,这是一种特殊情况。在任意一棵非空树中应满足:<br>①有且仅有一个特定的称为根的<code>结点</code>。<br>②当n&gt;1时,其余结点可分为m(m&gt;0)个互不相交的有限集合T1,T2…,Tn,其中每个集合本身又是一棵树,并且称为根结点的<code>子树</code>。</p><p><img src="https://img-blog.csdn.net/20180801094313847?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpZXJtaW5nX18=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h3 id="二、树的术语"><a href="#二、树的术语" class="headerlink" title="二、树的术语"></a>二、树的术语</h3><p><code>父结点</code>：若一个结点含有子结点，则这个结点称为其子结点的父结点<br><code>子结点</code>：一个结点含有的子树的根结点称为该结点的子结点<br><code>兄弟结点</code>：拥有共同父结点的结点互称为兄弟结点<br><code>祖先</code>：对任意结点x，从根结点到结点x的所有结点都是x的祖先（结点x也是自己的祖先）<br><code>后代</code>：对任意结点x，从结点x到叶子结点的所有结点都是x的后代（结点x也是自己的后代）</p><p><code>两结点的路径</code>：对任意结点x，从结点x到结点y的<code>从上到下</code>的路<br><code>两结点的路径长度</code>：对任意结点x，从结点x到结点y经过的边数</p><p><code>结点的层次</code>：对任意结点x，从根结点到结点x的<code>从上到下</code>经过的边数<br><code>结点高度</code>：对任意结点x，叶子结点到x结点的路径长度就是结点x的<code>高度</code><br><code>树的深度</code>：一棵树中结点的最大深度就是树的深度，也称为<code>高度</code></p><p><code>结点的度</code>：有几个子结点（分支）<br><code>树的度</code>：各结点的度的最大值<br><code>叶子结点</code>：度为零的结点就是叶子结点</p><p><code>森林</code>：m颗互不相交的树构成的集合就是森林</p><h3 id="三、树的分类"><a href="#三、树的分类" class="headerlink" title="三、树的分类"></a>三、树的分类</h3><p>有序树和无序树</p><p><code>有序树</code>一一逻辑上看，树中结点的各子树从左至右是有次序的，不能互换</p><p><img src="https://secure2.wostatic.cn/static/8PrtKV6j76SzKJvjRuNRKK/www.icode9.jpg?auth_key=1648522443-w38WYgftixomMPcABziZ1V-0-e322aaaf3ad3d6496339c3c59fbd0c2b" alt="img"></p><p><code>无序树</code>一一逻辑上看，树中结点的各子树从左至右是无次序的，可以互换</p><p><img src="https://secure2.wostatic.cn/static/8Z4B3f69T8pHTmtoJaeKCD/www.icode9.jpg?auth_key=1648522521-xpSKwMbbB6QeSkrJ6ymbnL-0-8b4f7ebb954a38643de4d08f4df5835d" alt="img"></p><h3 id="四、树的性质"><a href="#四、树的性质" class="headerlink" title="四、树的性质"></a>四、树的性质</h3><p>考点1：结点数&#x3D;总度数+1</p><p>考点2：度为m的树和m叉树<br><code>度为m的树</code>：至少有一个结点度&#x3D;m，一定是非空树<br><code>m叉树</code>：允许所有结点的度都≤m，可以是空树</p><p>考点3：度为m的树第i层至多有几个结点？$$m^{i-1}$$</p><p>考点4：高度为h的m叉树至多有几个结点？$$\frac{(m^{h}-1)}{(m-1)}$$</p><p>考点5：<br>高度为h的m叉树至少有多少个结点？$$h$$</p><p>高度为h、度为m的树至少有多少个结点？$$h+m-1$$</p><p>考点6：具有n个结点的m叉树的最小高度为？$$log_m\lceil (n(m-1)+1) \rceil$$</p><!----------------------------------------------------------------------------------><h2 id="二叉树-——-Binary-Tree"><a href="#二叉树-——-Binary-Tree" class="headerlink" title="二叉树 —— Binary Tree"></a>二叉树 —— Binary Tree</h2><h3 id="一、二叉树的定义："><a href="#一、二叉树的定义：" class="headerlink" title="一、二叉树的定义："></a>一、二叉树的定义：</h3><p><code>二叉树</code>是n(n≥0)个结点的有限集合<br>①或者为空二叉树，即n&#x3D;0。<br>②或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树<br>特点：①每个结点至多只有两棵子树 ②左右子树不能颠倒（二叉树是有序树）</p><p><img src="http://data.biancheng.net/uploads/allimg/181226/2-1Q226195I0M1.gif" alt="二叉树示意图"></p><h3 id="二、二叉树的五种状态"><a href="#二、二叉树的五种状态" class="headerlink" title="二、二叉树的五种状态"></a>二、二叉树的五种状态</h3><p><img src="https://upload-images.jianshu.io/upload_images/10852306-cecc753794d38154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/337/format/webp" alt="img"></p><h3 id="三、特殊的二叉树"><a href="#三、特殊的二叉树" class="headerlink" title="三、特殊的二叉树"></a>三、特殊的二叉树</h3><p><code>满二叉树</code>：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p><p><code>特点</code>：<br>①只有最后一层有叶子结点<br>②不存在度为1的结点<br>③按层序从1开始编号，结点i的左孩子为2i，右孩子为2+1；结点i的父节点为i&#x2F;2向下取整（如果有的话）</p><p><img src="http://data.biancheng.net/uploads/allimg/181226/2-1Q226195949495.gif" alt="满二叉树示意图"></p><p><code>完全二叉树</code>：当且仅当每个结点都与相同高度的满二叉树的编号一一对应</p><p>特点：<br>①只有最后两层可能有叶子结点<br>②最多只有一个度为1的结点<br>③按层序从1开始编号，结点i的左孩子为2i，右孩子为2+1；结点i的父节点为i&#x2F;2向下取整（如果有的话）<br>④i ≤ n&#x2F;2向下取整为分支结点，i ≥ n&#x2F;2向下取整为叶子结点</p><p><img src="http://data.biancheng.net/uploads/allimg/181226/2-1Q22620003J18.gif" alt="完全二叉树示意图"></p><p><code>二叉排序树</code>：一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字。</p><p><img src="https://bkimg.cdn.bcebos.com/pic/94cad1c8a786c9179df9bed6c93d70cf3ac75763?x-bce-process=image/resize,m_lfit,w_536,limit_1/format,f_jpg" alt="二叉排序树"></p><p><code>平衡二叉树</code>：树上任一结点的左子树和右子树的深度之差不超过1。</p><p><img src="https://img0.baidu.com/it/u=1329084275,842118972&fm=26&fmt=auto" alt="img"></p><h3 id="四、二叉树的性质"><a href="#四、二叉树的性质" class="headerlink" title="四、二叉树的性质"></a>四、二叉树的性质</h3><p>几个重要常考的基本操作：</p><ul><li><p>i的左孩子——2i</p></li><li><p>i的右孩子——2i+1</p></li><li><p>i的父节点——i&#x2F;2向下取整</p></li><li><p>i所在的层次 ——log2(n+1)向上取整 或 log2n向下取整+1</p></li></ul><p>若<code>完全二叉树</code>中共有n个结点（非完全二叉树不行），则</p><ul><li>判断i是否有左孩子？——2i≤n则有</li><li>·判断是否有右孩子？——2i+1&lt;n则有</li><li>判断i是否是叶子&#x2F;分支结点？——i&gt;n&#x2F;2向下取整是叶子结点，i&lt;n&#x2F;2向下取整是分支结点</li></ul><h3 id="五、存储结构"><a href="#五、存储结构" class="headerlink" title="五、存储结构"></a>五、存储结构</h3><p><code>顺序存储</code>和<code>链式存储</code>，一般用链式存储</p><h3 id="六、二叉树的顺序存储"><a href="#六、二叉树的顺序存储" class="headerlink" title="六、二叉树的顺序存储"></a>六、二叉树的顺序存储</h3><p>只适合存完全二叉树，普通二叉树会浪费很多空间</p><h4 id="二叉树的类型描述"><a href="#二叉树的类型描述" class="headerlink" title="二叉树的类型描述"></a>二叉树的类型描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>Elemtype value;    <span class="hljs-comment">//结点中的数据元素</span><br><span class="hljs-type">bool</span> isEmpty;      <span class="hljs-comment">//结点是否为空</span><br>&#125;;<br><br>TreeNode t[MaxSize];<br></code></pre></td></tr></table></figure><h4 id="初始化-10"><a href="#初始化-10" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">initBTree</span><span class="hljs-params">(TreeNode &amp;t)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;MaxSize; i++)&#123;<br>        t[i].isEmpty = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="七、二叉树的链式存储（二叉链表）"><a href="#七、二叉树的链式存储（二叉链表）" class="headerlink" title="七、二叉树的链式存储（二叉链表）"></a>七、二叉树的链式存储（二叉链表）</h3><h4 id="二叉树的类型表述"><a href="#二叉树的类型表述" class="headerlink" title="二叉树的类型表述"></a>二叉树的类型表述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>Elemtype data;                   <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchide</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左、右孩子指针</span><br>&#125;BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><p><code>注</code>：n个结点的二叉链表共有n+1个空链域</p><p>因为n个结点，有n-1个有指向；2n个指针，则指向NULL的个数&#x3D;2n-(n-1)&#x3D;n+1</p><h4 id="初始化（部分代码）"><a href="#初始化（部分代码）" class="headerlink" title="初始化（部分代码）"></a>初始化（部分代码）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elemtype</span>&#123;</span><br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-comment">//定义一颗空树</span><br>BiTree root = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//插入根结点</span><br>root = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));<br>root-&gt;data = &#123;<span class="hljs-number">1</span>&#125;;<br>root-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>root-&gt;rchild = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//插入新结点</span><br>BiTNode *p = (BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));<br>p-&gt;data = &#123;<span class="hljs-number">2</span>&#125;;<br>p-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>p-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>root-&gt;lchild = p;   <span class="hljs-comment">//作为根结点的左孩子</span><br></code></pre></td></tr></table></figure><h4 id="找结点p的父节点很难，解决："><a href="#找结点p的父节点很难，解决：" class="headerlink" title="找结点p的父节点很难，解决："></a>找结点p的父节点很难，解决：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>Elemtype data;                   <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchide</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左、右孩子指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">parent</span>;</span>          <span class="hljs-comment">//父节点指针</span><br>&#125;BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><h3 id="八、二叉树的遍历"><a href="#八、二叉树的遍历" class="headerlink" title="八、二叉树的遍历"></a>八、二叉树的遍历</h3><p>先序遍历、中序遍历、后序遍历</p><p><code>先序遍历</code>：根左右（NLR）</p><p><code>中序遍历</code>：左根右（LNR）</p><p><code>后序遍历</code>：左右根（LRN）</p><h4 id="代码：（用二叉树的链式存储）"><a href="#代码：（用二叉树的链式存储）" class="headerlink" title="代码：（用二叉树的链式存储）"></a>代码：（用二叉树的链式存储）</h4><p><img src="https://pic2.zhimg.com/80/v2-55f42c78e51c0de9d1b942278ee1cfc1_720w.jpg" alt="img"></p><p>先序遍历：每个结点都会被路过3次，第一次路过时访问结点</p><p><code>空间复杂度</code>&#x3D;O(h)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//先序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrder</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)&#123;<br>        visit(T);               <span class="hljs-comment">//访问根结点</span><br>        PreOrder(T-&gt;lchild);<span class="hljs-comment">//递归遍历左子树</span><br>        PreOrder(T-&gt;rchild);<span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中序遍历：每个结点都会被路过3次，第二次路过时访问结点</p><p><code>空间复杂度</code>&#x3D;O(h)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//中序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrder</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)&#123;<br>        InOrder(T-&gt;lchild);<span class="hljs-comment">//递归遍历左子树</span><br>        visit(T);               <span class="hljs-comment">//访问根结点</span><br>        InOrder(T-&gt;rchild);<span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后序遍历：每个结点都会被路过3次，第三次路过时访问结点</p><p><code>空间复杂度</code>&#x3D;O(h)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//后序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PostOrder</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)&#123;<br>        PostOrder(T-&gt;lchild);<span class="hljs-comment">//递归遍历左子树</span><br>        PostOrder(T-&gt;rchild);<span class="hljs-comment">//递归遍历右子树</span><br>        visit(T);               <span class="hljs-comment">//访问根结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><p>1.算数表达式的<code>分析树</code></p><p><code>先序遍历</code>-&gt;前缀表达式</p><p><code>中序遍历</code>-&gt;中缀表达式（需要加界限符）</p><p><code>后序遍历</code>-&gt;后缀表达式</p><p>2.求树的深度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求树的深度</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">treeDepth</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> l = treeDepth(T-&gt;lchild);<span class="hljs-comment">//左子树高度</span><br>        <span class="hljs-type">int</span> r = treeDepth(T-&gt;rchild);<span class="hljs-comment">//右子树高度</span><br>        <span class="hljs-comment">//树的深度=Max（左子树深度，右子树深度）+1</span><br>        <span class="hljs-keyword">return</span> l&gt;r ? l+<span class="hljs-number">1</span> : r+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="九、二叉树的层次遍历（层序遍历）"><a href="#九、二叉树的层次遍历（层序遍历）" class="headerlink" title="九、二叉树的层次遍历（层序遍历）"></a>九、二叉树的层次遍历（层序遍历）</h3><p><img src="https://pic4.zhimg.com/80/v2-e9eb296238feba1867dc2b7b6deec257_720w.jpg" alt="img"></p><p>算法思想：<br>①初始化一个辅助队列（链队列）<br>②根结点入队<br>③若队列非空，则队头结点出队，访问该结点并将其左、右孩子插入队尾(如果有的话)<br>④重复③直至队列为空</p><h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//类型描述</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>    <span class="hljs-comment">//定义单链表结点类型</span><br>ElemType data;            <span class="hljs-comment">//数据域，可以是别的各种数据类型，本文统一用int类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//指针域</span><br>&#125;LNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    LNode *front, *rear;<br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><h4 id="代码：（用二叉树的链式存储）-1"><a href="#代码：（用二叉树的链式存储）-1" class="headerlink" title="代码：（用二叉树的链式存储）"></a>代码：（用二叉树的链式存储）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//层次遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LevelOrder</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    LinkQueue Q;<br>    InitQueue(Q);<br>    BiTree p;    <span class="hljs-comment">//T为根结点，p也是根结点，保证根出队后可以指向孩子，因为T出队后，T-&gt;lchild无效</span><br>    EnQueue(Q, T);        <span class="hljs-comment">//根结点入队</span><br>    <span class="hljs-keyword">while</span>(!isEmpty(Q))&#123;   <span class="hljs-comment">//队列不空则循环</span><br>        DeQueue(Q, T);    <span class="hljs-comment">//根结点出队</span><br>        <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)<br>            EnQueue(Q, p-&gt;lchild);        <span class="hljs-comment">//左结点入队</span><br>        <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)<br>            EnQueue(Q, p-&gt;rchild);        <span class="hljs-comment">//右结点入队</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="十、由遍历序列构造二叉树"><a href="#十、由遍历序列构造二叉树" class="headerlink" title="十、由遍历序列构造二叉树"></a>十、由遍历序列构造二叉树</h3><p>1.前序+中序遍历序列</p><p>2.后序+中序遍历序列</p><p>3.层序+中序遍历序列</p><p>关键是有非中序确定根结点是谁，再将根结点代入中序得左右子树，依次类推。</p><!----------------------------------------------------------------------------------><h2 id="线索二叉树——Threaded-Binary-Tree"><a href="#线索二叉树——Threaded-Binary-Tree" class="headerlink" title="线索二叉树——Threaded Binary Tree"></a>线索二叉树——Threaded Binary Tree</h2><h3 id="一、线索二叉树定义"><a href="#一、线索二叉树定义" class="headerlink" title="一、线索二叉树定义"></a>一、线索二叉树定义</h3><p>背景：为解决遍历只能从根结点开始这个问题，因为普通二叉树找前驱和后继很麻烦</p><p><code>线索二叉树</code>在二叉树的结点上加上<code>线索</code>的二叉树。</p><h3 id="二、线索二叉树的存储结构"><a href="#二、线索二叉树的存储结构" class="headerlink" title="二、线索二叉树的存储结构"></a>二、线索二叉树的存储结构</h3><p>由二叉树的链式存储改进而来</p><h4 id="二叉树的类型表述-1"><a href="#二叉树的类型表述-1" class="headerlink" title="二叉树的类型表述"></a>二叉树的类型表述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>Elemtype data;                   <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchide</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左、右孩子指针</span><br>&#125;BiTNode, *BiTree;<br></code></pre></td></tr></table></figure><h4 id="线索二叉树的类型表述"><a href="#线索二叉树的类型表述" class="headerlink" title="线索二叉树的类型表述"></a>线索二叉树的类型表述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>Elemtype data;                   <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchide</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左、右孩子指针</span><br>    <span class="hljs-type">int</span> ltag, rtag;                  <span class="hljs-comment">//左、右线索标志</span><br>&#125;ThreadNode, *ThreadTree;<br></code></pre></td></tr></table></figure><p><code>tag==0</code>：表示指针指向<code>孩子</code><br><code>tag==1</code>：表示指针指向<code>线索</code></p><h3 id="三、线索二叉树的分类"><a href="#三、线索二叉树的分类" class="headerlink" title="三、线索二叉树的分类"></a>三、线索二叉树的分类</h3><p><code>中序线索二叉树</code>、<code>先序线索二叉树</code>、<code>后续线索二叉树</code></p><h3 id="四、二叉树线索化"><a href="#四、二叉树线索化" class="headerlink" title="四、二叉树线索化"></a>四、二叉树线索化</h3><p><code>对二叉树进行线索化</code>：对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程。</p><h4 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//全局变量pre，指向当前访问结点的前驱</span><br>ThreadNode *pre = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//中序线索化二叉树T(三种一样，只是调用线索化函数不同)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateThread</span><span class="hljs-params">(ThreadTree T)</span>&#123;<br>    pre = <span class="hljs-literal">NULL</span>;              <span class="hljs-comment">//pre初始为NULL</span><br>    <span class="hljs-keyword">if</span>(T != <span class="hljs-literal">NULL</span>)&#123;           <span class="hljs-comment">//非空二叉树才能线索化</span><br>        InTread(T);          <span class="hljs-comment">//中序线索化二叉树</span><br>        <span class="hljs-keyword">if</span>(pre-&gt;rchild == <span class="hljs-literal">NULL</span>)&#123;<br>            pre-&gt;rtag = <span class="hljs-number">1</span>;   <span class="hljs-comment">//处理遍历的最后一个结点</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历二叉树，一边遍历，一边线索化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrder</span><span class="hljs-params">(ThreadTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)&#123;<br>        InOrder(T-&gt;lchild);<span class="hljs-comment">//递归遍历左子树</span><br>        visit(T);               <span class="hljs-comment">//访问根结点</span><br>        InOrder(T-&gt;rchild);<span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//访问结点，顺便线索化（三种一样）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(TheadNode *q)</span>&#123;<br>    <span class="hljs-keyword">if</span>(q-&gt;lchild == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//左子树为空，建立前驱线索</span><br>        q-&gt;lchild = pre;<br>        q-&gt;ltag = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;rchild==<span class="hljs-literal">NULL</span>)&#123;<br>        pre-&gt;rchild = q; <span class="hljs-comment">//建立前驱结点的后继线索</span><br>        pre-&gt;rtage = <span class="hljs-number">1</span>;<br>    &#125;<br>    pre = q;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//全局变量pre，指向当前访问结点的前驱</span><br>ThreadNode *pre = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//先序线索化二叉树T(三种一样，只是调用线索化函数不同)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateThread</span><span class="hljs-params">(ThreadTree T)</span>&#123;<br>    pre = <span class="hljs-literal">NULL</span>;              <span class="hljs-comment">//pre初始为NULL</span><br>    <span class="hljs-keyword">if</span>(T != <span class="hljs-literal">NULL</span>)&#123;           <span class="hljs-comment">//非空二叉树才能线索化</span><br>        PreTread(T);         <span class="hljs-comment">//先序线索化二叉树</span><br>        <span class="hljs-keyword">if</span>(pre-&gt;rchild == <span class="hljs-literal">NULL</span>)&#123;<br>            pre-&gt;rtag = <span class="hljs-number">1</span>;   <span class="hljs-comment">//处理遍历的最后一个结点</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历二叉树，一边遍历，一边线索化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrder</span><span class="hljs-params">(ThreadTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)&#123;<br>        visit(T);               <span class="hljs-comment">//访问根结点</span><br>        <span class="hljs-keyword">if</span>(T-&gt;ltag == <span class="hljs-number">0</span>)        <span class="hljs-comment">//lchild不是前驱线索，是线索还遍历则无限循环</span><br>            InOrder(T-&gt;lchild);<span class="hljs-comment">//递归遍历左子树</span><br>        InOrder(T-&gt;rchild);    <span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//访问结点，顺便线索化（三种一样）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(TheadNode *q)</span>&#123;<br>    <span class="hljs-keyword">if</span>(q-&gt;lchild == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//左子树为空，建立前驱线索</span><br>        q-&gt;lchild = pre;<br>        q-&gt;ltag = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;rchild==<span class="hljs-literal">NULL</span>)&#123;<br>        pre-&gt;rchild = q; <span class="hljs-comment">//建立前驱结点的后继线索</span><br>        pre-&gt;rtage = <span class="hljs-number">1</span>;<br>    &#125;<br>    pre = q;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="后续线索化"><a href="#后续线索化" class="headerlink" title="后续线索化"></a>后续线索化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//全局变量pre，指向当前访问结点的前驱</span><br>ThreadNode *pre = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//后序线索化二叉树T(三种一样，只是调用线索化函数不同)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateThread</span><span class="hljs-params">(ThreadTree T)</span>&#123;<br>    pre = <span class="hljs-literal">NULL</span>;              <span class="hljs-comment">//pre初始为NULL</span><br>    <span class="hljs-keyword">if</span>(T != <span class="hljs-literal">NULL</span>)&#123;           <span class="hljs-comment">//非空二叉树才能线索化</span><br>        PostTread(T);        <span class="hljs-comment">//后序线索化二叉树</span><br>        <span class="hljs-keyword">if</span>(pre-&gt;rchild == <span class="hljs-literal">NULL</span>)&#123;<br>            pre-&gt;rtag = <span class="hljs-number">1</span>;   <span class="hljs-comment">//处理遍历的最后一个结点</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历二叉树，一边遍历，一边线索化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PostOrder</span><span class="hljs-params">(ThreadTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)&#123;<br>        InOrder(T-&gt;lchild);    <span class="hljs-comment">//递归遍历左子树</span><br>        InOrder(T-&gt;rchild);    <span class="hljs-comment">//递归遍历右子树</span><br>        visit(T);               <span class="hljs-comment">//访问根结点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//访问结点，顺便线索化（三种一样）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(TheadNode *q)</span>&#123;<br>    <span class="hljs-keyword">if</span>(q-&gt;lchild == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">//左子树为空，建立前驱线索</span><br>        q-&gt;lchild = pre;<br>        q-&gt;ltag = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;rchild==<span class="hljs-literal">NULL</span>)&#123;<br>        pre-&gt;rchild = q; <span class="hljs-comment">//建立前驱结点的后继线索</span><br>        pre-&gt;rtage = <span class="hljs-number">1</span>;<br>    &#125;<br>    pre = q;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、线索二叉树找前驱和后继"><a href="#五、线索二叉树找前驱和后继" class="headerlink" title="五、线索二叉树找前驱和后继"></a>五、线索二叉树找前驱和后继</h3><h4 id="1-1中序线索二叉树找中序后继"><a href="#1-1中序线索二叉树找中序后继" class="headerlink" title="1.1中序线索二叉树找中序后继"></a>1.1中序线索二叉树找中序后继</h4><p>在<code>中序线索二叉树</code>中找指定结点*p的<code>中序后继next</code></p><p>算法思想：</p><p>(1)若<code>p-&gt;rtag == 1</code>，则next为后继线索，即<code>next = p-&gt;rchild</code>。</p><p>(2)若<code>p-&gt;rtag == 0</code>，则p必有右孩子，<code>next为p的右子树中最左下结点</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//找到以P为根的子树中，第一个被中序遍历的结点</span><br>ThreadNode *<span class="hljs-title function_">Firstnode</span><span class="hljs-params">(ThreadNode *p)</span>&#123;<br>    <span class="hljs-comment">//循环找到最左下结点(不一定是叶子结点)</span><br>    <span class="hljs-keyword">while</span>(p-&gt;ltag == <span class="hljs-number">0</span>) p = p-&gt;lchild;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//在中序线索二叉树中找到结点p的后继结点</span><br>TheadNode *<span class="hljs-title function_">Nextnode</span><span class="hljs-params">(ThreadNode *p)</span>&#123;<br>    <span class="hljs-comment">//右子树中最左下结点</span><br>    <span class="hljs-keyword">if</span>(p-&gt;rtag == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Fistnode(p-&gt;rchild);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p-&gt;rchild;  <span class="hljs-comment">//rtag=1直接返回后继线索</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="应用：中序线索二叉树的中序遍历"><a href="#应用：中序线索二叉树的中序遍历" class="headerlink" title="应用：中序线索二叉树的中序遍历"></a>应用：中序线索二叉树的中序遍历</h5><p><code>空间复杂度</code>&#x3D;O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//对中序线索二又树进行中序遍历（利用线索实现的非递算法）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Inorder</span><span class="hljs-params">(ThreadNode *T)</span>&#123;<br>    <span class="hljs-keyword">for</span> (ThreadNode *p=Firstnode(T); p!=<span class="hljs-literal">NULL</span>; p=Nextnode(p))<br>visit (p);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2中序线索二叉树找中序前驱"><a href="#1-2中序线索二叉树找中序前驱" class="headerlink" title="1.2中序线索二叉树找中序前驱"></a>1.2中序线索二叉树找中序前驱</h4><p>在<code>中序线索二叉树</code>中找指定结点*p的<code>中序前驱pre</code></p><p>算法思想：</p><p>(1)若<code>p-&gt;rtag == 1</code>，则pre为前驱线索，即<code>pre = p-&gt;lchild</code>。</p><p>(2)若<code>p-&gt;rtag == 0</code>，则p必有左孩子，<code>pre为p的左子树中最右下结点</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//找到以P为根的子树中，最后一个被中序遍历的结点</span><br>ThreadNode *<span class="hljs-title function_">Lastnode</span><span class="hljs-params">(ThreadNode *p)</span>&#123;<br>    <span class="hljs-comment">//循环找到最右下结点(不一定是叶子结点)</span><br>    <span class="hljs-keyword">while</span>(p-&gt;rtag == <span class="hljs-number">0</span>) p = p-&gt;rchild;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">//在中序线索二叉树中找到结点p的前驱结点</span><br>TheadNode *<span class="hljs-title function_">Prenode</span><span class="hljs-params">(ThreadNode *p)</span>&#123;<br>    <span class="hljs-comment">//右子树中最左下结点</span><br>    <span class="hljs-keyword">if</span>(p-&gt;rtag == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Lastnode(p-&gt;lchild);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p-&gt;lchild;  <span class="hljs-comment">//rtag=1直接返回前驱线索</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="应用：中序线索二叉树的逆向中序遍历"><a href="#应用：中序线索二叉树的逆向中序遍历" class="headerlink" title="应用：中序线索二叉树的逆向中序遍历"></a>应用：中序线索二叉树的逆向中序遍历</h5><p><code>空间复杂度</code>&#x3D;O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//对中序线索二又树进行逆向中序遍历（利用线索实现的非递算法）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Inorder</span><span class="hljs-params">(ThreadNode *T)</span>&#123;<br>    <span class="hljs-keyword">for</span> (ThreadNode *p=Lastnode(T); p!=<span class="hljs-literal">NULL</span>; p=Prenode(p))<br>visit (p);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1先序线索二叉树找先序后继"><a href="#2-1先序线索二叉树找先序后继" class="headerlink" title="2.1先序线索二叉树找先序后继"></a>2.1先序线索二叉树找先序后继</h4><p>在<code>先序线索二叉树</code>中找指定结点*p的<code>先序后继next</code></p><p>先序遍历：根左右。</p><p>算法思想：</p><p>(1)若<code>p-&gt;rtag == 1</code>，则pre为前驱线索，即<code>next = p-&gt;rchild</code>。</p><p>(2)若<code>p-&gt;rtag == 0</code>，则</p><p>①若<code>p有左孩子</code>，则<code>next为左孩子</code></p><p>②若<code>p没有左孩子</code>，则<code>next为右孩子</code></p><h4 id="2-2先序线索二叉树找先序前驱"><a href="#2-2先序线索二叉树找先序前驱" class="headerlink" title="2.2先序线索二叉树找先序前驱"></a>2.2先序线索二叉树找先序前驱</h4><p>在<code>先序线索二叉树</code>中找指定结点*p的<code>先序前驱pre</code></p><p>由于先序遍历：根左右。p结点的左右子树中的结点只能是根的后继，不可能是前驱，因此<code>无法找前驱</code></p><p><code>解决</code>：改用三叉链表，三个指针：指向父结点、左孩子结点和右孩子结点</p><p>算法思想：</p><p>(1)若<code>p-&gt;rtag == 1</code>，则pre为前驱线索，即<code>pre = p-&gt;lchild</code>。</p><p>(2)若<code>p-&gt;rtag == 0</code>，则</p><p>​①若<code>能找到p的父结点</code>且<code>p是左孩子</code>，则<code>pre为父结点</code></p><p>​②若<code>能找到p的父结点</code>且<code>p是右孩子</code>，其<code>左兄弟为空</code>，则<code>pre为父结点</code></p><p>​②若<code>能找到p的父结点</code>且<code>p是右孩子</code>，其<code>左兄弟为非空</code>，则<code>pre为左兄弟子树中最后一个被先序遍历的结点</code>。</p><h4 id="3-1后序线索二叉树找后序后继"><a href="#3-1后序线索二叉树找后序后继" class="headerlink" title="3.1后序线索二叉树找后序后继"></a>3.1后序线索二叉树找后序后继</h4><p>在<code>后序线索二叉树</code>中找指定结点*p的<code>后序后继next</code></p><p>由于后序遍历：左右根。p结点的左右子树中的结点只能是根的后前驱，不可能是后继，因此&#96;无法找前后继</p><p><code>解决</code>：改用三叉链表，三个指针：指向父结点、左孩子结点和右孩子结点</p><p>算法思想：</p><p>(1)若<code>p-&gt;rtag == 1</code>，则next为后继线索，即<code>next = p-&gt;rchild</code>。</p><p>(2)若<code>p-&gt;rtag == 0</code>，则</p><p>​①若<code>能找到p的父结点</code>且<code>p是右孩子</code>，则<code>next为父结点</code></p><p>​②若<code>能找到p的父结点</code>且<code>p是左孩子</code>，其<code>右兄弟为空</code>，则<code>next为父结点</code></p><p>​②若<code>能找到p的父结点</code>且<code>p是左孩子</code>，其<code>右兄弟为非空</code>，则<code>next为左兄弟子树中第一个被后续序遍历的结点</code>。</p><h4 id="3-2后序线索二叉树找后序前驱"><a href="#3-2后序线索二叉树找后序前驱" class="headerlink" title="3.2后序线索二叉树找后序前驱"></a>3.2后序线索二叉树找后序前驱</h4><p>在<code>后序线索二叉树</code>中找指定结点*p的<code>后序前驱pre</code></p><p>先序遍历：左右根。</p><p>算法思想：</p><p>(1)若<code>p-&gt;rtag == 1</code>，则pre为前驱线索，即<code>pre = p-&gt;lchild</code>。</p><p>(2)若<code>p-&gt;rtag == 0</code>，则</p><p>①若<code>p有右孩子</code>，则<code>pre为右孩子</code></p><p>②若<code>p没有右孩子</code>，则<code>pre为左孩子</code></p><!----------------------------------------------------------------------------------><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="一、存储结构"><a href="#一、存储结构" class="headerlink" title="一、存储结构"></a>一、存储结构</h3><p><code>顺序存储</code>和<code>链式存储</code></p><p>方法：<br><code>双亲表示法</code>（顺序存储）<br><code>孩子表示法</code>（顺序+链式存储）<br><code>孩子兄弟表示法</code>（链式存储）</p><h3 id="二、双亲表示法（顺序存储）"><a href="#二、双亲表示法（顺序存储）" class="headerlink" title="二、双亲表示法（顺序存储）"></a>二、双亲表示法（顺序存储）</h3><p><img src="https://img-blog.csdnimg.cn/20200205124743184.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dteTAyMTdf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>双亲表示法：<code>顺序存储</code>结点数据，结点中保存父结点在数组中的下标</p><p><code>优点</code>：找父节点方便。<br><code>缺点</code>：找孩子不方便。</p><p><code>注</code>：双亲表示法与二叉树的顺序存储不一样，双亲表示法也可表示二叉树</p><h4 id="类型描述"><a href="#类型描述" class="headerlink" title="类型描述"></a>类型描述</h4><p><code>结点</code>包括<code>数据</code>和<code>父亲下标</code>，<br><code>树</code>包括<code>结点数组</code>和<code>结点个数</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100         <span class="hljs-comment">//树中最多结点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>                   <span class="hljs-comment">//树的结点定义</span><br>    ElemType data;                <span class="hljs-comment">//数据元素</span><br>    <span class="hljs-type">int</span> parent;                   <span class="hljs-comment">//双亲位置域</span><br>&#125;PTNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>                   <span class="hljs-comment">//树的类型定义</span><br>    PTNode nodes[MAX_TREE_SIZE];  <span class="hljs-comment">//双亲表示</span><br>    <span class="hljs-type">int</span> n;                        <span class="hljs-comment">//结点数</span><br>&#125;PTree;<br></code></pre></td></tr></table></figure><h4 id="增加一个结点"><a href="#增加一个结点" class="headerlink" title="增加一个结点"></a>增加一个结点</h4><p>新增元素，无需按逻辑次序存储，可以放到删除结点留下的存储空间里</p><h4 id="删除一个结点"><a href="#删除一个结点" class="headerlink" title="删除一个结点"></a>删除一个结点</h4><p>方案一：数据取出，双亲指针改为-1</p><p>方案二：用存储空间中最后一个存的结点把要删的结点覆盖</p><h4 id="查找一个结点"><a href="#查找一个结点" class="headerlink" title="查找一个结点"></a>查找一个结点</h4><p>找父结点方便、找孩子不方便。</p><p>空数据导致遍历慢。</p><h3 id="二、孩子表示法（顺序-链式存储）"><a href="#二、孩子表示法（顺序-链式存储）" class="headerlink" title="二、孩子表示法（顺序+链式存储）"></a>二、孩子表示法（顺序+链式存储）</h3><p><img src="https://img-blog.csdnimg.cn/2020020513261515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dteTAyMTdf,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>孩子表示法：<code>顺序存储</code>结点数据，结点中保存孩子<code>链表</code>头指针（<code>链式存储</code>）</p><p><code>优点</code>：找孩子方便。<br><code>缺点</code>：找父节点不方便。</p><h4 id="类型描述-1"><a href="#类型描述-1" class="headerlink" title="类型描述"></a>类型描述</h4><p><code>孩子结点</code>包括<code>孩子下标</code>和<code>下一个孩子指针</code>，<br><code>数组</code>包括<code>数据</code>和<code>孩子结点</code>，<br><code>树</code>包括<code>数组</code>和<code>数组元素（结点）个数</code>及<code>根的下标</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100         <span class="hljs-comment">//树中最多结点数</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span>&#123;</span><br>    <span class="hljs-type">int</span> child;                    <span class="hljs-comment">//孩子结点在数组中的位置</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> *<span class="hljs-title">next</span>;</span>          <span class="hljs-comment">//下一个孩子</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span>* <span class="hljs-title">firstchild</span>;</span>    <span class="hljs-comment">//第一个孩子</span><br>&#125;CTBox;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    CTBox nodes[MAX_TREE_SIZE];<br><span class="hljs-type">int</span> n, r;                     <span class="hljs-comment">//结点数和根的位置</span><br>&#125;CTree;<br></code></pre></td></tr></table></figure><h4 id="增加一个结点-1"><a href="#增加一个结点-1" class="headerlink" title="增加一个结点"></a>增加一个结点</h4><p>新增元素，父结点后新增一个孩子结点，数组中加一个数组元素</p><h4 id="删除一个结点-1"><a href="#删除一个结点-1" class="headerlink" title="删除一个结点"></a>删除一个结点</h4><p>父结点后的链表中将此结点删除</p><p>数组中：<br>①若此结点后无链表，则直接删除<br>②若此结点后有链表，再处理子树</p><h4 id="查找一个结点-1"><a href="#查找一个结点-1" class="headerlink" title="查找一个结点"></a>查找一个结点</h4><p>按图一行一行遍历</p><p>找孩子结点方便，找父结点不方便</p><h3 id="三、孩子兄弟表示法（顺序-链式存储）"><a href="#三、孩子兄弟表示法（顺序-链式存储）" class="headerlink" title="三、孩子兄弟表示法（顺序+链式存储）"></a>三、孩子兄弟表示法（顺序+链式存储）</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F453%2Fcc517c2353eb55fee933453aec89c3d5.png&refer=http%3A%2F%2Fwww.pianshen.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1639041091&t=4bf03e7d98ff4795bf1faac99745914e" alt="点击查看源网页"></p><p>孩子兄弟表示法：用<code>二叉链表</code>存储<code>树</code>——<code>两个指针</code>：<code>第一个孩子</code>和<code>右兄弟</code></p><p>用此方法存储的树，形态上和<code>二叉树</code>类似</p><h4 id="类型描述-2"><a href="#类型描述-2" class="headerlink" title="类型描述"></a>类型描述</h4><p>由二叉树的链式存储（二叉链表）改变而来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span>&#123;</span><br>Elemtype data;                   <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSTNode</span> *<span class="hljs-title">firstchild</span>, *<span class="hljs-title">nextsibling</span>;</span> <span class="hljs-comment">//第一个孩子和右兄弟指针</span><br>&#125;CSTNode, *CSTree;<br></code></pre></td></tr></table></figure><h4 id="应用：树和二叉树的转换"><a href="#应用：树和二叉树的转换" class="headerlink" title="应用：树和二叉树的转换"></a>应用：树和二叉树的转换</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637759667705.png" alt="1637759667705"></p><h3 id="四、森林和二叉树的转换"><a href="#四、森林和二叉树的转换" class="headerlink" title="四、森林和二叉树的转换"></a>四、森林和二叉树的转换</h3><p>本质：用<code>二叉链表</code>存储<code>森林</code></p><p>将森林的根结点连起来，视为兄弟关系</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637759667694.png" alt="1637759667694"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637759667683.jpg" alt="1637759667683"></p><!----------------------------------------------------------------------------------><h2 id="二叉排序树——Binary-Search-Tree"><a href="#二叉排序树——Binary-Search-Tree" class="headerlink" title="二叉排序树——Binary Search Tree"></a>二叉排序树——Binary Search Tree</h2><h3 id="一、二叉排序树的定义"><a href="#一、二叉排序树的定义" class="headerlink" title="一、二叉排序树的定义"></a>一、二叉排序树的定义</h3><p><code>二叉排序树</code>，又称<code>二叉查找树</code>(<code>BST</code>, <code>Binary Search Tree</code>)</p><p>定义：一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：<br><code>左子树</code>上所有结点的关键字均<code>小于</code> <code>根结点</code>的关键字；<br><code>右子树</code>上所有结点的关键字均<code>大于</code> <code>根结点</code>的关键字。<br>左子树和右子树又各是一棵二叉排序树。</p><p><code>左子树结点值&lt;根结点值&lt;右子树结点值</code><br>进行<code>中序遍历</code>,可以得到一个<code>递增的有序序列</code></p><p><code>作用</code>：元素的有序组织、<code>搜索</code>。</p><p><img src="https://bkimg.cdn.bcebos.com/pic/94cad1c8a786c9179df9bed6c93d70cf3ac75763?x-bce-process=image/resize,m_lfit,w_536,limit_1/format,f_jpg" alt="二叉排序树"></p><h3 id="二、二叉排序树的存储结构（用链式存储）"><a href="#二、二叉排序树的存储结构（用链式存储）" class="headerlink" title="二、二叉排序树的存储结构（用链式存储）"></a>二、二叉排序树的存储结构（用链式存储）</h3><p>二叉排序树的类型表述（与二叉树一样）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br><span class="hljs-type">int</span> data;                   <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchide</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左、右孩子指针</span><br>&#125;BSTNode, *BSTree;<br></code></pre></td></tr></table></figure><h3 id="三、二叉排序树的查找"><a href="#三、二叉排序树的查找" class="headerlink" title="三、二叉排序树的查找"></a>三、二叉排序树的查找</h3><p>非递归好于递归</p><p>算法思想：<br>若树非空，目标值与根结点的值比较：<br>        若相等，则查找成功。<br>        若小于根结点,则在左子树上查找,否则在右子树上查找。<br>查找成功,返回结点指针;查找失败返回NULL。</p><h5 id="递归查找"><a href="#递归查找" class="headerlink" title="递归查找"></a>递归查找</h5><p><code>最坏空间复杂度</code>&#x3D;O(h)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在二叉排序树中查找值为key的结点（递归实现）</span><br>BSTNode *<span class="hljs-title function_">BST_Search</span><span class="hljs-params">(BSTree T,<span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(key == T-&gt;data) <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; T-&gt;data)<br><span class="hljs-keyword">return</span> BST_Search( T-&gt;lchild, key);<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> BST_Search( T-&gt;rchild, key);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="非递归查找"><a href="#非递归查找" class="headerlink" title="非递归查找"></a>非递归查找</h5><p><code>最坏空间复杂度</code>&#x3D;O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在二叉排序树中查找值为key的结点</span><br>BSTNode *<span class="hljs-title function_">NoRBST_Search</span><span class="hljs-params">(BSTree T,<span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-keyword">while</span>(T!=<span class="hljs-literal">NULL</span> &amp;&amp; key!=T-&gt;data)&#123;<br>        <span class="hljs-keyword">if</span>(key &lt; T-&gt;data) T = T-&gt;lchild;<br>        <span class="hljs-keyword">else</span> T = T-&gt;rchild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、二叉排序树的插入"><a href="#四、二叉排序树的插入" class="headerlink" title="四、二叉排序树的插入"></a>四、二叉排序树的插入</h3><p>非递归好于递归</p><p>算法思想：<br>若原二叉排序树为空，则直接插入结点；<br>否则，若关键字k小于根结点值,则插入到左子树，若关键字k大于根结点值，则插入到右子树</p><h4 id="递归插入"><a href="#递归插入" class="headerlink" title="递归插入"></a>递归插入</h4><p><code>最坏空间复杂度</code>&#x3D;O(h)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在二叉排序树插入关键字为k的新结点(递归实现)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">BST_Insert</span><span class="hljs-params">(BSTree &amp;T,<span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)&#123;                          <span class="hljs-comment">//树为空，则插入根结点</span><br>        T = (BSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BSTNode));<br>        T-&gt;data = k;<br>        T-&gt;lchild = T-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(key == T-&gt;data)&#123;                     <span class="hljs-comment">//树中存在相同关键字的结点，插入失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; T-&gt;data)&#123;<br>        <span class="hljs-keyword">return</span> BST_Insert( T-&gt;lchild, key);  <span class="hljs-comment">//插入到T的左子树</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> BST_Insert( T-&gt;rchild, key);  <span class="hljs-comment">//插入到T的右子树</span><br>    &#125;<br>&#125;   <br></code></pre></td></tr></table></figure><h4 id="非递归插入"><a href="#非递归插入" class="headerlink" title="非递归插入"></a>非递归插入</h4><p><code>最坏空间复杂度</code>&#x3D;O(1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//二叉排序树非递归插入，最坏空间复杂度Sn=O(1)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">NoRBST_Insert</span><span class="hljs-params">(BSTree &amp;T, <span class="hljs-type">int</span> key)</span> &#123;<br>    BSTNode *pre = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//二叉树里最后一个结点</span><br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">//原来树为空，申请结点将其插入进去</span><br>        T = (BSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BSTNode));<br>        T-&gt;data = key;<br>        T-&gt;lchild = T-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   <span class="hljs-comment">//成功插入</span><br>    &#125;<br> <br>    <span class="hljs-comment">//获取到最后一个结点</span><br>    <span class="hljs-keyword">while</span>(T != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span>(key == T-&gt;data) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//二叉排序树里不可能存在相同的结点，插入失败</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; T-&gt;data) &#123;<br>            pre = T;<br>            T = T-&gt;lchild;<span class="hljs-comment">//遍历左孩子</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre = T;<br>            T = T-&gt;rchild;<span class="hljs-comment">//遍历右孩子</span><br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">//插入到左子树</span><br>    <span class="hljs-keyword">if</span> (key &lt; pre-&gt;data) &#123;<br>        T = (BSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BSTNode));<br>        T-&gt;data = key;<br>        pre-&gt;lchild = T;<br>    &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">//到了此步已经不存在等于的情况</span><br>        <span class="hljs-comment">//插入到右子树</span><br>        T = (BSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BSTNode));<br>        T-&gt;data = key;<br>        pre-&gt;rchild = T;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、二叉排序树的构造"><a href="#五、二叉排序树的构造" class="headerlink" title="五、二叉排序树的构造"></a>五、二叉排序树的构造</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//按照str[]中的关键字序建立二叉排序树</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Creat_BST</span><span class="hljs-params">(BSTree &amp;T, <span class="hljs-type">int</span> str[],<span class="hljs-type">int</span> n)</span>&#123;<br>    T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>        BST_Insert(T,str[i]);<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="六、二叉排序树的删除"><a href="#六、二叉排序树的删除" class="headerlink" title="六、二叉排序树的删除"></a>六、二叉排序树的删除</h3><p>先搜索找到目标结点z：</p><p>①若被删除结点z是<code>叶子结点</code>，则<code>直接删除</code>，不会破坏二叉排序树的性质。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1636465960055.png" alt="1636465960055"></p><p>②若结点z只有一颗左子树或右子树，则让z的子树分为z父结点的子树，代替z的位置</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1636465960051.png" alt="1636465960051"></p><p>③若结点z有左、右两棵子树，则令z的直接后继(或直接前驱)替代z，然后从二叉排序树中删去这个直接后继(或直接前驱)，这样就转换成了第一或第二种情况。</p><p>直接后继代替</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1636465960047.png" alt="1636465960047"></p><p>直接前驱代替</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1636466293090.png" alt="1636466293090"></p><h3 id="七、查找效率的分析"><a href="#七、查找效率的分析" class="headerlink" title="七、查找效率的分析"></a>七、查找效率的分析</h3><p>查找长度：对比关键字的次数，反映了查找操作的时间复杂度。</p><p>与高度h有关。高度越小，查找效率越高</p><p>平衡二叉树的查找效率最高，也是最好情况</p><p>最好情况，平均查找长度&#x3D;O(log<del>2</del>n)</p><p>最坏情况，平均查找长度&#x3D;O(n)</p><h4 id="平均查找长度计算"><a href="#平均查找长度计算" class="headerlink" title="平均查找长度计算"></a>平均查找长度计算</h4><p>查找<code>成功</code>的平均查找长度：</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637587381063.png" alt="1637587381063"></p><p>查找<code>失败</code>的平均查找长度：</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637587381058.png" alt="1637587381058"></p><!----------------------------------------------------------------------------------><h2 id="平衡二叉树——Balanced-Binary-Tree"><a href="#平衡二叉树——Balanced-Binary-Tree" class="headerlink" title="平衡二叉树——Balanced Binary Tree"></a>平衡二叉树——Balanced Binary Tree</h2><h3 id="一、平衡二叉树的定义"><a href="#一、平衡二叉树的定义" class="headerlink" title="一、平衡二叉树的定义"></a>一、平衡二叉树的定义</h3><p><code>平衡二叉树</code>,又被称为<code>AVL树</code>（有别于AVL算法），且具有以下性质：</p><p>它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p>AVL是两个人的名字，ASL是平均查找长度，不一样</p><p><code>结点的平衡因子=左子树高-右子树高</code></p><p>平衡二叉树结点的平衡因子的值只可能是-1、0、1。</p><p><img src="https://images2015.cnblogs.com/blog/805461/201601/805461-20160127214903223-1113949071.jpg" alt="img"></p><h3 id="二、平衡二叉树的存储结构（用链式存储）"><a href="#二、平衡二叉树的存储结构（用链式存储）" class="headerlink" title="二、平衡二叉树的存储结构（用链式存储）"></a>二、平衡二叉树的存储结构（用链式存储）</h3><p>平衡二叉树的类型表述（与二叉树不一样）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span>&#123;</span><br><span class="hljs-type">int</span> key;      <span class="hljs-comment">//数据域</span><br>    <span class="hljs-type">int</span> balance;  <span class="hljs-comment">//平衡因子</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span> *<span class="hljs-title">lchide</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左、右孩子指针</span><br>&#125;AVLNode, *AVLTree;<br></code></pre></td></tr></table></figure><h3 id="三、平衡二叉树的插入"><a href="#三、平衡二叉树的插入" class="headerlink" title="三、平衡二叉树的插入"></a>三、平衡二叉树的插入</h3><p>在平衡的二叉排序树中插入一个结点导致不平衡，如何调整平衡？<br>解决方法：调整<code>“最小不平衡树”</code></p><p>四种调整方法：<br>①LL：在A的<code>左孩子的左子树</code>中插入导致A的不平衡，将A的<code>左孩子右上旋</code>。<br>②RR：在A的<code>右孩子的右子树</code>中插入导致A的不平衡，将A的<code>右孩子左上旋</code>。<br>③LR：在A的<code>左孩子的右子树</code>中插入导致A的不平衡，将A的<code>左孩子的右孩子，先左上旋再右上旋</code>。<br>④RL：在A的<code>右孩子的左子树</code>中插入导致A的不平衡，将A的<code>右孩子的左孩子，先右上旋再左上旋</code>。</p><h3 id="四、查找效率分析"><a href="#四、查找效率分析" class="headerlink" title="四、查找效率分析"></a>四、查找效率分析</h3><p><code>平均查找的时间复杂度</code>&#x3D;O(log<del>2</del>h)</p><h3 id="五、高度为h的平衡二叉树的最少结点数"><a href="#五、高度为h的平衡二叉树的最少结点数" class="headerlink" title="五、高度为h的平衡二叉树的最少结点数"></a>五、高度为h的平衡二叉树的最少结点数</h3><p><code>递推公式</code>：$$n_h&#x3D;n_{h-1}+n_{h-2}+1$$</p><!----------------------------------------------------------------------------------><h2 id="哈夫曼树——Huffman-Tree"><a href="#哈夫曼树——Huffman-Tree" class="headerlink" title="哈夫曼树——Huffman Tree"></a>哈夫曼树——Huffman Tree</h2><h3 id="一、带权路径长度"><a href="#一、带权路径长度" class="headerlink" title="一、带权路径长度"></a>一、带权路径长度</h3><p>结点的<code>权</code>：有某种现实含义的数值（如：结点的重要性等）</p><p><code>结点的带权路径长度=该结点的路径长度×该结点的权值</code></p><p><code>树的带权路径长度</code>&#x3D;所有<code>叶结点</code>的<code>带权路径长度之和</code></p><h3 id="二、哈夫曼树的定义"><a href="#二、哈夫曼树的定义" class="headerlink" title="二、哈夫曼树的定义"></a>二、哈夫曼树的定义</h3><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的<code>带权路径长度达到最小</code>，称这样的二叉树为<code>最优二叉树</code>，也称为<code>哈夫曼树</code>(Huffman Tree)。</p><p>哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p><img src="https://bkimg.cdn.bcebos.com/pic/5366d0160924ab1886c1109d3ffae6cd7a890b40?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5/format,f_auto" alt="img"></p><h3 id="三、哈夫曼树的构造"><a href="#三、哈夫曼树的构造" class="headerlink" title="三、哈夫曼树的构造"></a>三、哈夫曼树的构造</h3><p>哈夫曼树构造的树可以不同，但带权路径长度相同</p><h3 id="四、哈夫曼编码"><a href="#四、哈夫曼编码" class="headerlink" title="四、哈夫曼编码"></a>四、哈夫曼编码</h3><p>①固定长度编码：平衡二叉树</p><p>②可变长度编码：哈夫曼树（最优二叉树）</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637761333305.jpg" alt="1637761333305"></p><!----------------------------------------------------------------------------------><h2 id="图——Graph"><a href="#图——Graph" class="headerlink" title="图——Graph"></a>图——Graph</h2><h3 id="一、图的定义"><a href="#一、图的定义" class="headerlink" title="一、图的定义"></a>一、图的定义</h3><p><code>图G</code>由<code>顶点集V</code>和<code>边集E</code>组成，记$$G&#x3D;(V，E)$$。</p><p>$$|V|$$表示图G中顶点的个数，也称图G的阶。</p><p>$$|E|$$表示图G中边的条数。</p><p>注：线性表可以是空表，树可以是空树，但<code>图不可以为空</code>，即V一定是非空集</p><h3 id="二、图的分类"><a href="#二、图的分类" class="headerlink" title="二、图的分类"></a>二、图的分类</h3><p>①有向图和无向图。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637762644688.png" alt="1637762644688"></p><p>②简单图和多重图</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637762901031.png" alt="1637762901031"></p><h3 id="三、顶点的度，入度、出度"><a href="#三、顶点的度，入度、出度" class="headerlink" title="三、顶点的度，入度、出度"></a>三、顶点的度，入度、出度</h3><p>无向图：<br>顶点的度&#x3D;连该顶点的边的条数<br>无入度出度概念</p><p>有向图：<br>入度&#x3D;指向该点的边的条数<br>出度&#x3D;从该点指向其它点的边的条数<br>顶点的度&#x3D;连该顶点的边的条数&#x3D;入度出度之和</p><h3 id="四、顶点与顶点之间的关系"><a href="#四、顶点与顶点之间的关系" class="headerlink" title="四、顶点与顶点之间的关系"></a>四、顶点与顶点之间的关系</h3><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637763340772.png" alt="1637763340772"></p><h3 id="五、连通图、强连通图"><a href="#五、连通图、强连通图" class="headerlink" title="五、连通图、强连通图"></a>五、连通图、强连通图</h3><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637763511883.png" alt="1637763511883"></p><h3 id="六、子图、生成子图"><a href="#六、子图、生成子图" class="headerlink" title="六、子图、生成子图"></a>六、子图、生成子图</h3><p>子图：点集是子集，边集是子集<br>生成子图：点集不变，边集是子集。</p><h3 id="七、连通分量、强连通分量"><a href="#七、连通分量、强连通分量" class="headerlink" title="七、连通分量、强连通分量"></a>七、连通分量、强连通分量</h3><p>连通分量：无向图的极大连通子图<br>强连通分量：有向图的极大连通子图</p><h3 id="八、生成树、生成森林"><a href="#八、生成树、生成森林" class="headerlink" title="八、生成树、生成森林"></a>八、生成树、生成森林</h3><p>连通图可以生成树<br>非连通图可以生成森林</p><h3 id="九、特殊的图"><a href="#九、特殊的图" class="headerlink" title="九、特殊的图"></a>九、特殊的图</h3><p>①无向完全图、有向完全图<br>无向完全图：无向图中任意两个顶点之间都存在边<br>有向完全图：有向图中任意两个顶点之间都存在相反的两条弧</p><p>②稀疏图、稠密图<br>稀疏图：边很少的图<br>稠密图：边很多的图</p><p>③树、有向树<br>树：不存在回路、且连通的无向图<br>有向树：一个顶点的入度为0，其余顶点的入度为1 的有向图</p><!----------------------------------------------------------------------------------><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="一、图的存储结构"><a href="#一、图的存储结构" class="headerlink" title="一、图的存储结构"></a>一、图的存储结构</h3><p>①领接矩阵：顺序存储（一维数组存点的数据，二维数组存边的连接情况）(存储无向图、有向图)<br>②邻接表：顺序+链式存储（顺序存点的数据，链存连接该点的边）（存储有向图、无向图）<br>③十字链表：链式存储（存储有向图）<br>④邻接多重表：链式存储（存储无向图）</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637936258196.png" alt="1637936258196"></p><h3 id="二、邻接矩阵法"><a href="#二、邻接矩阵法" class="headerlink" title="二、邻接矩阵法"></a>二、邻接矩阵法</h3><p><code>空间复杂度</code>&#x3D;$$O(|V|^2)$$，<code>适合存稠密图</code></p><p><code>无向图的邻接矩阵</code>是<code>对称矩阵</code>，可以<code>压缩存储</code>，见3.6</p><p><code>性质</code>：$$A$$为图$$G$$的邻接矩阵，则$$A^n$$的元素$$A^n[i][j]$$&#x3D;<code>顶点i到顶点j的长度为n的路径的数目</code></p><p><code>计算度、入度、出度</code>：必须遍历对应的行或列。<br><code>找相邻的边</code>：必须遍历对应的行或列。</p><h4 id="1-1普通图的领接矩阵法："><a href="#1-1普通图的领接矩阵法：" class="headerlink" title="1.1普通图的领接矩阵法："></a>1.1普通图的领接矩阵法：</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637846244394.png" alt="1637846244394"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100                 <span class="hljs-comment">//顶点数目最大值</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span> Vex[MaxVertexNum];              <span class="hljs-comment">//顶点表：存每个点的数据</span><br>    <span class="hljs-type">int</span> Edge[MaxVertexNum][MaxVertexNum];<span class="hljs-comment">//邻接矩阵，边表：存边的连接情况</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;                  <span class="hljs-comment">//图当前的顶点数和边数（弧数）</span><br>&#125;MGraph;<br></code></pre></td></tr></table></figure><p>边可以是int，bool或枚举型变量。</p><h4 id="1-2普通图的度、入度、出度"><a href="#1-2普通图的度、入度、出度" class="headerlink" title="1.2普通图的度、入度、出度"></a>1.2普通图的度、入度、出度</h4><p>某点的度：某点的边数</p><p>无向图：<br><code>第i个结点的度</code>&#x3D;<code>第i行(第i列)</code>的<code>非零元素</code>个数。</p><p>有向图：<br><code>第i个结点的出度</code>&#x3D;<code>第i行</code>的<code>非零元素</code>个数。<br><code>第i个结点的入度</code>&#x3D;<code>第i列</code>的<code>非零元素</code>个数。<br><code>第i个结点的度</code>&#x3D;<code>第i行、第i列</code>的<code>非零元素</code>个数<code>之和</code>。</p><p>求顶点的度、入度、出度的<code>时间复杂度</code>&#x3D;O($$|V|$$)</p><h4 id="2-带权图的领接矩阵法"><a href="#2-带权图的领接矩阵法" class="headerlink" title="2.带权图的领接矩阵法"></a>2.带权图的领接矩阵法</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637848061168.png" alt="1637848061168"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100                 <span class="hljs-comment">//顶点数目最大值</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFINITY 4294967295              <span class="hljs-comment">//宏定义常量“无穷”，4294967295为最大的int值</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VertexType;                 <span class="hljs-comment">//顶点的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> EdgeType;                    <span class="hljs-comment">//边的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    VertexType Vex[MaxVertexNum];        <span class="hljs-comment">//顶点表：存每个点的数据</span><br>    EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="hljs-comment">//邻接矩阵，边表：存边的连接情况</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;                  <span class="hljs-comment">//图当前的顶点数和边数（弧数）</span><br>&#125;MGraph;<br></code></pre></td></tr></table></figure><h3 id="三、邻接表法"><a href="#三、邻接表法" class="headerlink" title="三、邻接表法"></a>三、邻接表法</h3><p><code>空间复杂度</code>：无向图为$$O(|V|+2|E|)$$，有向图为$$O(|V|+|E|)$$，<code>适合存稀疏图</code><br><code>表示方式不唯一</code></p><p>邻接矩阵降低了空间复杂度，但使操作不方便了：<br><code>计算度、入度、出度</code>：计算有向图的度、入度不方便，其余很方便。<br><code>找相邻的边</code>：找有向图的入边不方便。</p><h4 id="图的类型描述："><a href="#图的类型描述：" class="headerlink" title="图的类型描述："></a>图的类型描述：</h4><p>与树的孩子表示法很像</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637934445539.jpg" alt="1637934445539"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100       <span class="hljs-comment">//顶点数目最大值</span></span><br><span class="hljs-comment">//&quot;边（弧）&quot;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>&#123;</span><br>    <span class="hljs-type">int</span> adjvex;                <span class="hljs-comment">//边（弧）指向那个结点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">next</span>;</span>      <span class="hljs-comment">//指向下一条弧的指针</span><br>    <span class="hljs-comment">//InfoType info;           //边权值</span><br>&#125;ArcNode;<br><span class="hljs-comment">//&quot;顶点&quot;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VNode</span>&#123;</span><br>    VertexType data;           <span class="hljs-comment">//顶点数据</span><br>    ArcNode *first;            <span class="hljs-comment">//顶点指向的第一条边</span><br>&#125;VNode, AdjList[MaxVertexNum];<br><span class="hljs-comment">//用领接表存储图</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    AdjList vertices;          <span class="hljs-comment">//顶点数组</span><br>    <span class="hljs-type">int</span> vernum, arcnum;        <span class="hljs-comment">////图当前的顶点数和边数（弧数）</span><br>&#125;ALGraph;<br></code></pre></td></tr></table></figure><h3 id="四、十字链表法"><a href="#四、十字链表法" class="headerlink" title="四、十字链表法"></a>四、十字链表法</h3><p><code>空间复杂度</code>：$$O(|V|+|E|)$$，与邻接表法一样</p><p>解决了邻接表法的找入边难的问题。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637936499284.png" alt="1637936499284"></p><h3 id="五、邻接多重表"><a href="#五、邻接多重表" class="headerlink" title="五、邻接多重表"></a>五、邻接多重表</h3><p><code>空间复杂度</code>：$$O(|V|+|E|)$$，比邻接表法的$$O(|V|+2|E|)$$好</p><p>解决了邻接表法存两遍边的空间浪费。</p><p>删除边、删除结点等操作很方便。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637936777739.png" alt="1637936777739"></p><!----------------------------------------------------------------------------------><h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//图的基本操作</span><br>Adjacent(G,x,y);     <span class="hljs-comment">//判断图G是否存在边&lt;x,y&gt;或(x,y)。</span><br>Neighbors(G,x);      <span class="hljs-comment">//列出图G中与结点x邻接的边。</span><br>InsertVertex(G,x);   <span class="hljs-comment">//在图G中插入顶点x。</span><br>DeleteVertex(G,x);   <span class="hljs-comment">//从图G中删除顶点x。</span><br>AddEdge(G,x,y);      <span class="hljs-comment">//若无向边(x,y)或有向边&lt;x,y&gt;不存在，则向图G中添加该边。</span><br>RemoveEdge(G,x,y);   <span class="hljs-comment">//若无向边(x,y)或有向边&lt;x,y&gt;存在，则从图G中删除该边。</span><br>FirstNeighbor(G,x);  <span class="hljs-comment">//求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。</span><br>NextNeighbor(G,x,y); <span class="hljs-comment">//假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。</span><br>Get_edge_value(G,x,y);   <span class="hljs-comment">//获取图G中边(x,y)或&lt;x,y&gt;对应的权值。</span><br>Set_edge_value(G,x,y,v); <span class="hljs-comment">//设置图G中边(x,y)或&lt;x,y&gt;对应的权值为v。</span><br></code></pre></td></tr></table></figure><p>图的遍历中直接调用FirstNeighbor(G, x);和NextNeighbor(G, x, y);</p><!----------------------------------------------------------------------------------><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="一、图的遍历"><a href="#一、图的遍历" class="headerlink" title="一、图的遍历"></a>一、图的遍历</h3><p>广度优先遍历、深度优先遍历</p><h3 id="二、广度优先遍历（BFS）"><a href="#二、广度优先遍历（BFS）" class="headerlink" title="二、广度优先遍历（BFS）"></a>二、广度优先遍历（BFS）</h3><p>与<code>树</code>的广度优先搜索（<code>层次遍历</code>）很像。</p><p>需要一个<code>辅助链队列</code>。</p><p>树的层次遍历的算法思想：<br>①初始化一个辅助队列（链队列）<br>②根结点入队<br>③若队列非空，则队头结点出队，访问该结点并将其<code>左、右孩子</code>插入队尾(如果有的话)<br>④重复③直至队列为空</p><p>图的广度优先搜索的算法思想：<br>①初始化一个辅助队列（链队列）<br>②结点入队<br>③若队列非空，则队头结点出队，访问该结点并将其<code>相邻顶点</code>插入队尾(如果有的话)<br>④重复③直至队列为空</p><p>树没有回路，不可能搜到已访问结点<br>图有可能搜索到已访问的结点<br>解决方法：<code>用一个数组标记顶点的访问</code></p><h4 id="链队列-1"><a href="#链队列-1" class="headerlink" title="链队列"></a>链队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//类型描述</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span>    <span class="hljs-comment">//定义单链表结点类型</span><br>ElemType data;            <span class="hljs-comment">//数据域，可以是别的各种数据类型，本文统一用int类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//指针域</span><br>&#125;LNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    LNode *front, *rear;<br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//树的层次遍历（广度优先搜索）（用二叉树的链式存储）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LevelOrder</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    LinkQueue Q;<br>    InitQueue(Q);<br>    BiTree p;   <span class="hljs-comment">//T为根结点，p也是根结点，保证根出队后可以指向孩子，因为T出队后，T-&gt;lchild无效</span><br>    EnQueue(Q, T);        <span class="hljs-comment">//根结点入队</span><br>    <span class="hljs-keyword">while</span>(!isEmpty(Q))&#123;   <span class="hljs-comment">//队列不空则循环</span><br>        DeQueue(Q, T);    <span class="hljs-comment">//根结点出队</span><br>        <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)<br>            EnQueue(Q, p-&gt;lchild);        <span class="hljs-comment">//左结点入队</span><br>        <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)<br>            EnQueue(Q, p-&gt;rchild);        <span class="hljs-comment">//右结点入队</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//图的广度优先搜索（用图的邻接矩阵、领接表都可以，只是FirstNeighbor和NextNeighbor函数实现不一样）</span><br><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];     <span class="hljs-comment">//访问标记数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFSTraverse</span><span class="hljs-params">(Graph G)</span>&#123;        <span class="hljs-comment">//对图G进行广度优先搜索</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>; v&lt;G.vexnum; ++v)&#123;<br>        visited[v] = <span class="hljs-literal">false</span>;       <span class="hljs-comment">//初始化访问标记数组</span><br>    &#125;<br>    InitQueue(Q);                 <span class="hljs-comment">//初始化辅助队列Q</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>; v&lt;G.vexnum; ++v)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[v])&#123;          <span class="hljs-comment">//对每个连通分量调用一次BFS</span><br>            BFS(G,v);             <span class="hljs-comment">//vi没访问过，从vi开始BFS</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span>&#123;<br>visit(v);             <span class="hljs-comment">//访问初始顶点v</span><br>    visited[v] = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//对v做已访问标记</span><br>    EnQueue(Q, v);        <span class="hljs-comment">//顶点v入队</span><br>    <span class="hljs-keyword">while</span>(!isEmpty(Q))&#123;   <span class="hljs-comment">//队列不空则循环</span><br>        DeQueue(Q, v);    <span class="hljs-comment">//顶点v出队</span><br>        <span class="hljs-keyword">for</span>(w=FirstNeighbor(G,v); w&gt;=<span class="hljs-number">0</span>; w=NextNeighbor(G,v,w))&#123;<span class="hljs-comment">//检测v所有的邻接顶点</span><br>            <span class="hljs-keyword">if</span>(!visited[w])&#123;          <span class="hljs-comment">//w为v尚未访问的邻接顶点</span><br>visit(w);             <span class="hljs-comment">//访问顶点w</span><br>    visited[w] = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//对w做已访问标记</span><br>                EnQueue(Q, w);        <span class="hljs-comment">//顶点w入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><code>空间复杂度</code>&#x3D;$$O(|V|)$$</p><p><code>时间复杂度</code>：<br><code>邻接矩阵</code>&#x3D;$$O(|V|^2)$$，<code>邻接表</code>&#x3D;$$O(|V|+|E|)$$</p><p>原理：<br>邻接矩阵：访问点&#x3D;$$O(|V|)$$，访问边&#x3D;$$O(|V|^2)$$，时间复杂度&#x3D;$$O(|V|)+O(|V|^2)&#x3D;O(|V|^2)$$<br>邻接表：访问点&#x3D;$$O(|V|)$$，访问无向边&#x3D;$$O(2|E|)$$，访问无向边&#x3D;$$O(|E|)$$，<br>               <code>无向图</code>时间复杂度&#x3D;$$O(|V|)+O(2|E|)&#x3D;O(|V|+|E|)$$<br>               <code>有向图</code>时间复杂度&#x3D;$$O(|V|)+O(|E|)&#x3D;O(|V|+|E|)$$</p><h4 id="广度优先生成树、森林"><a href="#广度优先生成树、森林" class="headerlink" title="广度优先生成树、森林"></a>广度优先生成树、森林</h4><p>连通图生成树，非连通图生森林</p><p>由于领接矩阵表示法唯一，领接表法表示不唯一<br>导致邻接矩阵生成树唯一，领接表生成树不唯一</p><h3 id="三、深度优先遍历（DFS）"><a href="#三、深度优先遍历（DFS）" class="headerlink" title="三、深度优先遍历（DFS）"></a>三、深度优先遍历（DFS）</h3><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>与<code>树</code>的<code>先序遍历</code>很像。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//树的先序遍历（深度优先遍历）（用二叉树的链式存储）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrder</span><span class="hljs-params">(BiTree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)&#123;<br>        visit(T);               <span class="hljs-comment">//访问根结点</span><br>        PreOrder(T-&gt;lchild);<span class="hljs-comment">//递归遍历左子树</span><br>        PreOrder(T-&gt;rchild);<span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//图的深度优先搜索（用图的邻接矩阵、领接表都可以，只是FirstNeighbor和NextNeighbor函数实现不一样）</span><br><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];     <span class="hljs-comment">//访问标记数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFSTraverse</span><span class="hljs-params">(Graph G)</span>&#123;        <span class="hljs-comment">//对图G进行广度优先搜索</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>; v&lt;G.vexnum; ++v)&#123;<br>        visited[v] = <span class="hljs-literal">false</span>;       <span class="hljs-comment">//初始化访问标记数组</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>; v&lt;G.vexnum; ++v)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[v])&#123;          <span class="hljs-comment">//对每个连通分量调用一次BFS</span><br>            BFS(G,v);             <span class="hljs-comment">//vi没访问过，从vi开始BFS</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span>&#123;<br>    visit(v);             <span class="hljs-comment">//访问初始顶点v</span><br>    visited[v] = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//对v做已访问标记</span><br>    <span class="hljs-keyword">for</span>(w=FirstNeighbor(G,v); w&gt;=<span class="hljs-number">0</span>; w=NextNeighbor(G,v,w))&#123;<span class="hljs-comment">//检测v所有的邻接顶点</span><br>        <span class="hljs-keyword">if</span>(!visit[w])&#123;          <span class="hljs-comment">//w为v尚未访问的邻接顶点</span><br>            DFS(G, w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="复杂度分析（与BFS一样）"><a href="#复杂度分析（与BFS一样）" class="headerlink" title="复杂度分析（与BFS一样）"></a>复杂度分析（与BFS一样）</h4><p><code>空间复杂度</code>&#x3D;$$O(|V|)$$，来自递归工作站</p><p><code>时间复杂度</code>：<br><code>邻接矩阵</code>&#x3D;$$O(|V|^2)$$，<code>邻接表</code>&#x3D;$$O(|V|+|E|)$$</p><p>原理：<br>邻接矩阵：访问点&#x3D;$$O(|V|)$$，访问边&#x3D;$$O(|V|^2)$$，时间复杂度&#x3D;$$O(|V|)+O(|V|^2)&#x3D;O(|V|^2)$$<br>邻接表：访问点&#x3D;$$O(|V|)$$，访问无向边&#x3D;$$O(2|E|)$$，访问无向边&#x3D;$$O(|E|)$$，<br>               <code>无向图</code>时间复杂度&#x3D;$$O(|V|)+O(2|E|)&#x3D;O(|V|+|E|)$$<br>               <code>有向图</code>时间复杂度&#x3D;$$O(|V|)+O(|E|)&#x3D;O(|V|+|E|)$$</p><h4 id="深度优先生成树、森林（与BFS一样）"><a href="#深度优先生成树、森林（与BFS一样）" class="headerlink" title="深度优先生成树、森林（与BFS一样）"></a>深度优先生成树、森林（与BFS一样）</h4><p>连通图生成树，非连通图生森林</p><p>由于领接矩阵表示法唯一，领接表法表示不唯一<br>导致邻接矩阵生成树唯一，领接表生成树不唯一</p><h3 id="四、图的遍历与图的连通性"><a href="#四、图的遍历与图的连通性" class="headerlink" title="四、图的遍历与图的连通性"></a>四、图的遍历与图的连通性</h3><p><code>无向图</code>进行BFS&#x2F;DFS遍历：<code>调用BFS/DFS次数=连通分量数</code><br>连通图只需调用一次BFS&#x2F;DFS</p><p><code>有向图</code>进行BFS&#x2F;DFS遍历：要具体分析<br>若起始顶点到其它顶点都有路径，则只需调用一次<br>强连通图从任意结点都只需调用一次BFS&#x2F;DFS</p><!----------------------------------------------------------------------------------><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="一、最小生成树的概念"><a href="#一、最小生成树的概念" class="headerlink" title="一、最小生成树的概念"></a>一、最小生成树的概念</h3><p>连通图生成树，非连通图生成森林</p><p><code>生成树</code>是包含图中全部顶点的一个<code>极小连通子图</code><br><code>特性</code>：图中有n个顶点，则它的生成树含有n-1条边。<br>去除一条边会变成非连通图；加上一条边会变成一个回路</p><p>之前学过<code>广度优先生成树</code>和<code>深度优先生成树</code>。</p><p><code>最小生成树</code>，也叫<code>最小代价树</code>。在带权连通无向图的所有生成树中，所有边的代价和最小。</p><p>最小生成树可能很多，但边的权值之和总是唯一且最小的。</p><p><code>最小生成的边=顶点数-1</code></p><p><img src="https://img-blog.csdn.net/20160714130435508" alt="这里写图片描述"></p><h3 id="二、Prim算法（普利姆算法）"><a href="#二、Prim算法（普利姆算法）" class="headerlink" title="二、Prim算法（普利姆算法）"></a>二、Prim算法（普利姆算法）</h3><p>此算法可以称为<code>“加点法”</code>，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p><p>实现思想：以最低代价加入<code>点</code>。<br>用两个数组：<br>①<code>isJoin数组</code>：标记<code>各结点</code>是否已加入树。<br>②<code>lowCost数组</code>：各节点加入树的最低代价。</p><p>每轮遍历<strong>isJoin</strong>数组，第一遍找到<strong>lowCost</strong>最低的顶点，然后加入；第二遍循环遍历更新各点的<strong>lowCost</strong>值。<br>则<code>时间复杂度</code>&#x3D;$$O(|V|^2)$$，适合<code>边稠密图</code></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638175026761.png" alt="1638175026761"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638175026757.png" alt="1638175026757"></p><h3 id="三、Kruskal算法（克鲁斯卡尔算法）"><a href="#三、Kruskal算法（克鲁斯卡尔算法）" class="headerlink" title="三、Kruskal算法（克鲁斯卡尔算法）"></a>三、Kruskal算法（克鲁斯卡尔算法）</h3><p>此算法可以称为<code>“加边法”</code>，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。</p><p>实现思想：以最低代价加入<code>边</code>。<br>用一个表：<br>（weight（边权），Vertex1（点1），Vertex2（点2））<br>用<code>并查集</code>检查下一个边的两个点是否已连接。</p><p>判断两个点是否已连接需要$$O(log_2|E|)$$，工执行e轮。<br>则<code>时间复杂度</code>&#x3D;$$O(|E|log_2|E|)$$，适合<code>边稀疏图</code></p><!----------------------------------------------------------------------------------><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638172106501.png" alt="1638172106501"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638178148141.png" alt="1638178148141"></p><h3 id="一、BFS算法（无权图）"><a href="#一、BFS算法（无权图）" class="headerlink" title="一、BFS算法（无权图）"></a>一、BFS算法（无权图）</h3><p>由<code>广度优先算法</code>求最短路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//图的广度优先搜索（用图的邻接矩阵、领接表都可以，只是FirstNeighbor和NextNeighbor函数实现不一样）</span><br><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];     <span class="hljs-comment">//访问标记数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFSTraverse</span><span class="hljs-params">(Graph G)</span>&#123;        <span class="hljs-comment">//对图G进行广度优先搜索</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>; v&lt;G.vexnum; ++v)&#123;<br>        visited[v] = <span class="hljs-literal">false</span>;       <span class="hljs-comment">//初始化访问标记数组</span><br>    &#125;<br>    InitQueue(Q);                 <span class="hljs-comment">//初始化辅助队列Q</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>; v&lt;G.vexnum; ++v)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[v])&#123;          <span class="hljs-comment">//对每个连通分量调用一次BFS</span><br>            BFS(G,v);             <span class="hljs-comment">//vi没访问过，从vi开始BFS</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span>&#123;<br>visit(v);             <span class="hljs-comment">//访问初始顶点v</span><br>    visited[v] = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//对v做已访问标记</span><br>    EnQueue(Q, v);        <span class="hljs-comment">//顶点v入队</span><br>    <span class="hljs-keyword">while</span>(!isEmpty(Q))&#123;   <span class="hljs-comment">//队列不空则循环</span><br>        DeQueue(Q, v);    <span class="hljs-comment">//顶点v出队</span><br>        <span class="hljs-keyword">for</span>(w=FirstNeighbor(G,v); w&gt;=<span class="hljs-number">0</span>; w=NextNeighbor(G,v,w))&#123;<span class="hljs-comment">//检测v所有的邻接顶点</span><br>            <span class="hljs-keyword">if</span>(!visited[w])&#123;          <span class="hljs-comment">//w为v尚未访问的邻接顶点</span><br>visit(w);             <span class="hljs-comment">//访问顶点w</span><br>    visited[w] = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//对w做已访问标记</span><br>                EnQueue(Q, w);        <span class="hljs-comment">//顶点w入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现方式：<br>用两个数组：<br>①<code>d数组</code>：记录各点的路径长度。<br>②<code>path数组</code>：记录各点的前驱。</p><p><code>时间复杂度</code>：</p><p><code>邻接矩阵</code>&#x3D;$$O(|V|^2)$$，<code>邻接表</code>&#x3D;$$O(|V|+|E|)$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用BFS求顶点U到其它顶点的最短路径（只改了visit函数调用的两行）</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFINITY 4294967295       <span class="hljs-comment">//宏定义常量“无穷”，4294967295为最大的int值</span></span><br><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];     <span class="hljs-comment">//访问标记数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span>&#123;<br><span class="hljs-comment">//d[i]表示从u到i结点的最短路径</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;G.vexnum; ++i)&#123;<br>        d[i] = INFINITY;  <span class="hljs-comment">//初始化路径长度</span><br>        path[i] = <span class="hljs-number">-1</span>;     <span class="hljs-comment">//最短路径从哪个顶点过来</span><br>    &#125;<br>    d[u] = <span class="hljs-number">0</span>;             <span class="hljs-comment">//从u开始</span><br>    visited[v] = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//对v做已访问标记</span><br>    EnQueue(Q, v);        <span class="hljs-comment">//顶点v入队</span><br>    <span class="hljs-keyword">while</span>(!isEmpty(Q))&#123;   <span class="hljs-comment">//队列不空则循环</span><br>        DeQueue(Q, v);    <span class="hljs-comment">//顶点v出队</span><br>        <span class="hljs-keyword">for</span>(w=FirstNeighbor(G,v); w&gt;=<span class="hljs-number">0</span>; w=NextNeighbor(G,v,w))&#123;<span class="hljs-comment">//检测v所有的邻接顶点</span><br>            <span class="hljs-keyword">if</span>(!visited[w])&#123;          <span class="hljs-comment">//w为v尚未访问的邻接顶点</span><br>d[w] = d[u] + <span class="hljs-number">1</span>;      <span class="hljs-comment">//路径长度加1</span><br>                path[w] = u;          <span class="hljs-comment">//最短路径应从u到w</span><br>    visited[w] = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//对w做已访问标记</span><br>                EnQueue(Q, w);        <span class="hljs-comment">//顶点w入队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、Dijkstra算法（迪杰斯特拉算法）（带权图、无权图）"><a href="#二、Dijkstra算法（迪杰斯特拉算法）（带权图、无权图）" class="headerlink" title="二、Dijkstra算法（迪杰斯特拉算法）（带权图、无权图）"></a>二、Dijkstra算法（迪杰斯特拉算法）（带权图、无权图）</h3><p><code>BFS算法的局限性：不适用带权图</code></p><p>实现方式：<br>用两个数组：<br>①<code>final数组</code>：记录各顶点是否已找到最短路径。<br>②<code>dist数组</code>：记录各点的最短路径长度。<br>③<code>path数组</code>：记录各点路径上的前驱。</p><p>每轮遍历<strong>final</strong>数组，第一遍找到<strong>dist</strong>最低的顶点，然后加入；第二遍循环遍历更新各点的<strong>dist</strong>值和<strong>path</strong>值。<br>则<code>时间复杂度</code>&#x3D;$$O(|V|^2)$$</p><p><code>Dijkstra算法的局限性：不适用负权值带权图</code>。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638175026752.png" alt="1638175026752"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638175026747.png" alt="1638175026747"></p><h3 id="三、Floyd算法（弗洛伊德算法）（带权图、无权图）"><a href="#三、Floyd算法（弗洛伊德算法）（带权图、无权图）" class="headerlink" title="三、Floyd算法（弗洛伊德算法）（带权图、无权图）"></a>三、Floyd算法（弗洛伊德算法）（带权图、无权图）</h3><p>实现方式：<br>用两个二维数组：<br>①<code>A数组</code>：记录各顶点之间目前的最短路径长度<br>②<code>path数组</code>：记录两点之间的第一个中转点。</p><p>以某一点为中转点遍历二维数组，更新两个数组，将所有点作为中转点都遍历一遍，形成三重循环<br>则<code>时间复杂度</code>&#x3D;$$O(|V|^3)$$，<code>空间复杂度</code>&#x3D;$$O(|V|^2)$$。</p><p><code>Floyd算法的局限性：不适用负权值带权图</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//省略初始化A和path数组</span><br><span class="hljs-comment">//Floyd算法的核心</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;n; k++)&#123;          <span class="hljs-comment">//考虑以Vk作为中转点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;      <span class="hljs-comment">//遍历整个矩阵，i为行号，j为列号</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(A[i][j] &gt; A[i][k] + A[k][j])&#123;    <span class="hljs-comment">//以Vk作为中转点的路径更短</span><br>                A[i][j] = A[i][k] + A[k][j];    <span class="hljs-comment">//更新最短路径长度</span><br>                path[i][j] = k;                 <span class="hljs-comment">//中转点</span><br>            &#125;<br>    &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><!----------------------------------------------------------------------------------><h2 id="有向无环图——Directed-Acyclic-Graph"><a href="#有向无环图——Directed-Acyclic-Graph" class="headerlink" title="有向无环图——Directed Acyclic Graph"></a>有向无环图——Directed Acyclic Graph</h2><h3 id="一、有向无环图定义"><a href="#一、有向无环图定义" class="headerlink" title="一、有向无环图定义"></a>一、有向无环图定义</h3><p><code>有向无环图</code>：有向图中不存在环，又称<code>DAG图</code>。</p><h3 id="二、有向无环图描述表达式"><a href="#二、有向无环图描述表达式" class="headerlink" title="二、有向无环图描述表达式"></a>二、有向无环图描述表达式</h3><p>由表达式画<code>最少顶点</code>的有向无环图：</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638191188272.png" alt="1638191188272"></p><!----------------------------------------------------------------------------------><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="一、AOV网"><a href="#一、AOV网" class="headerlink" title="一、AOV网"></a>一、AOV网</h3><p><code>AOV网</code>（Activity On Vertex NetWork，用<code>顶点表示活动</code>的网）：<br>用DAG图（<code>有向无环图</code>）表示一个工程。<br><code>顶点表示活动</code>，边$$&lt;V_i,V_j&gt;$$表示活动$$V_i$$必须先于活动$$V_j$$进行</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638194953695.png" alt="uTools_1638194953695"></p><h3 id="二、拓扑排序"><a href="#二、拓扑排序" class="headerlink" title="二、拓扑排序"></a>二、拓扑排序</h3><p>有向无环图中当且仅当满足下列条件时，称为该图的一个拓扑排序：<br>①每个顶点出现且只出现一次<br>②若顶点A在序列中排在B的前面，则在图中不存在从B到A的路径</p><p>每个AOV网有多个拓扑排序序列。</p><p><code>拓扑排序：找到做事的先后顺序。</code></p><p>拓扑排序的实现：<br>①从AOV网中选择一个没有前驱（入度为0）的顶点并输出。<br>② 从网中删除该顶点和所有以它为起点的有向边。<br>③ 重复①和②直到当前的AOV网为空或当前网中不存在无前驱的顶点为止。</p><h4 id="图的类型描述：-1"><a href="#图的类型描述：-1" class="headerlink" title="图的类型描述："></a>图的类型描述：</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1637934445539.jpg" alt="1637934445539"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100       <span class="hljs-comment">//顶点数目最大值</span></span><br><span class="hljs-comment">//&quot;边（弧）&quot;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span>&#123;</span><br>    <span class="hljs-type">int</span> adjvex;                <span class="hljs-comment">//边（弧）指向那个结点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">next</span>;</span>      <span class="hljs-comment">//指向下一条弧的指针</span><br>    <span class="hljs-comment">//InfoType info;           //边权值</span><br>&#125;ArcNode;<br><span class="hljs-comment">//&quot;顶点&quot;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VNode</span>&#123;</span><br>    VertexType data;           <span class="hljs-comment">//顶点数据</span><br>    ArcNode *first;            <span class="hljs-comment">//顶点指向的第一条边</span><br>&#125;VNode, AdjList[MaxVertexNum];<br><span class="hljs-comment">//用领接表存储图</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    AdjList vertices;          <span class="hljs-comment">//顶点数组</span><br>    <span class="hljs-type">int</span> vernum, arcnum;        <span class="hljs-comment">////图当前的顶点数和边数（弧数）</span><br>&#125;ALGraph;<br></code></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">TopologicalSort</span><span class="hljs-params">(Graph G)</span>&#123;<br>    InitStack(S);            <span class="hljs-comment">//初始化栈，存储入度为0的顶点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;G.vexnum; i++)&#123;<br>        <span class="hljs-keyword">if</span>(indegree[i] == <span class="hljs-number">0</span>)&#123;<br>            Push(S,i);       <span class="hljs-comment">//将所有入度为0的顶点进栈</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>；          <span class="hljs-comment">//计数，记录当前已经输出的顶点数</span><br><span class="hljs-keyword">while</span>(!IsEmpty(S))&#123;      <span class="hljs-comment">//栈不空，则存在入度为0的顶点</span><br>        Pop(S,i);            <span class="hljs-comment">//栈顶元素出栈</span><br>        print[count++] = i;    <span class="hljs-comment">//输出顶点i</span><br>        <span class="hljs-keyword">for</span>(p=G.vertices[i].firstarc; p; p=p-&gt;nextarc)&#123;<span class="hljs-comment">//p是顶点第一个指向的结点，p存在则循环</span><br>            <span class="hljs-comment">//将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈s</span><br>            v = p-&gt;adjvex;     <span class="hljs-comment">//v是结点p中存的顶点号</span><br>            <span class="hljs-keyword">if</span>(!(--indegree[v]))   <span class="hljs-comment">//入度先减1，再判断是否为0</span><br>                Push(S,v);   <span class="hljs-comment">//入度为0，则入栈</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(count &lt; G.vexnum)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//排序失败，有向图中有回路</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <span class="hljs-comment">//拓扑排序成功</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638194223550.jpg" alt="1638194223550"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638194223556.png" alt="1638194223556"></p><!----------------------------------------------------------------------------------><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><h3 id="一、AOE网"><a href="#一、AOE网" class="headerlink" title="一、AOE网"></a>一、AOE网</h3><p><code>AOE网</code>（Activity On Edge NetWork，用<code>边表示活动</code>的网）：<br><code>带权有向图</code>中，<code>顶点表示事件</code>，<code>有向边表示活动</code>，<code>边上的权值表示完成该活动的开销</code>。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638194800008.png" alt="uTools_1638194800008"></p><p>AOE网具有以下两个性质：<br>①只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；<br>② 只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。<br>另外，有些活动是可以并行进行的</p><p>在AOE网中仅有一个入度为0的顶点，称为<code>开始顶点（源点）</code>，它表示整个工程的开始；<br>也仅有一个出度为0的顶点，称为<code>结束顶点（汇点）</code>，它表示整个工程的结束。</p><h3 id="二、关键路径"><a href="#二、关键路径" class="headerlink" title="二、关键路径"></a>二、关键路径</h3><p><code>从源点到汇点</code>的<code>有向路径</code>可能有多条，所有路径中，具有<code>最大路径长度</code>的路径称为<br><code>关键路径</code>，而把<code>关键路径上的活动</code>称为<code>关键活动</code></p><p><code>特性</code>：<br>若关键活动耗时增加，则整个工程的工期将增长<br>缩短关键活动的时间，可以缩短整个工程的工期<br>当缩短到一定程度时，关键活动可能会变成非关键活动</p><p>可能有多条关键路径，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</p><p><code>计算</code>：<br>事件最早、最迟发生时间<br>活动最早、最迟开始时间<br>活动的时间余量&#x3D;活动最迟开始-最早开始</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638195067535.png" alt="uTools_1638195067535"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638195535394.png" alt="uTools_1638195535394"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638195638068.png" alt="uTools_1638195638068"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638195751296.png" alt="uTools_1638195751296"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638195723961.png" alt="uTools_1638195723961"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638195438535.png" alt="uTools_1638195438535"></p><!----------------------------------------------------------------------------------><h2 id="查找——Search"><a href="#查找——Search" class="headerlink" title="查找——Search"></a>查找——Search</h2><h3 id="一、查找的基本概念"><a href="#一、查找的基本概念" class="headerlink" title="一、查找的基本概念"></a>一、查找的基本概念</h3><p><code>查找</code>：在数据集合中寻找满足某种条件的数据元素的过程称为查找。<br><code>查找表</code>（查找结构）：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成。<br><code>关键字</code>：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638241191170.png" alt="uTools_1638241191170"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638241230449.png" alt="uTools_1638241230449"></p><h3 id="二、对查找表的常见操作"><a href="#二、对查找表的常见操作" class="headerlink" title="二、对查找表的常见操作"></a>二、对查找表的常见操作</h3><p>查找和插入、删除</p><p><code>静态查找表</code>只关注<code>查找速度</code>，<code>动态查找表</code>既关注<code>查找速度</code>又关注<code>插入删除是否方便</code>。</p><h3 id="三、查找算法的评价指标"><a href="#三、查找算法的评价指标" class="headerlink" title="三、查找算法的评价指标"></a>三、查找算法的评价指标</h3><p><code>查找长度</code>：对比关键字的次数</p><p><code>平均查找长度(ASL)</code>：对比关键字次数的平均值。</p><p>$$ASL&#x3D;\sum_{i&#x3D;1}^{n}{P_iC_i}$$——查找概率×查找长度的总和</p><p><code>ASL反映了查找算法的时间复杂度。</code></p><h4 id="查找成功和查找失败的平均查找长度："><a href="#查找成功和查找失败的平均查找长度：" class="headerlink" title="查找成功和查找失败的平均查找长度："></a>查找成功和查找失败的平均查找长度：</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638242765366.jpg" alt="1638242765366"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638242765362.jpg" alt="1638242765362"></p><!----------------------------------------------------------------------------------><h2 id="顺序查找——Sequential-Search"><a href="#顺序查找——Sequential-Search" class="headerlink" title="顺序查找——Sequential Search"></a>顺序查找——Sequential Search</h2><h3 id="一、顺序查找的定义"><a href="#一、顺序查找的定义" class="headerlink" title="一、顺序查找的定义"></a>一、顺序查找的定义</h3><p><code>顺序查找</code>，又叫<code>线性查找</code>。</p><h3 id="二、顺序查找的实现"><a href="#二、顺序查找的实现" class="headerlink" title="二、顺序查找的实现"></a>二、顺序查找的实现</h3><p><code>算法思想</code>：从头挨个查找。</p><p>普通代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//查找表的数据结构（动态分配的顺序表）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *elem;      <span class="hljs-comment">//指向“动态”分配的数组的指针</span><br>    <span class="hljs-type">int</span> TableLen;        <span class="hljs-comment">//查找表的当前长度</span><br>&#125;SSTable;<br><span class="hljs-comment">//顺序查找</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST, ElemType key)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;ST.TableLen &amp;&amp; ST.elem[i]!=key; ++i)&#123;<span class="hljs-comment">//从前往后找，判断是否越界</span><br>        <span class="hljs-keyword">return</span> i==ST.TableLen? <span class="hljs-number">-1</span> : i;   <span class="hljs-comment">//查找成功，则返回元素下标；查找失败，则返回-1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有哨兵的代码：不用判断越界，效率更高</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//查找表的数据结构（动态分配的顺序表）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *elem;      <span class="hljs-comment">//指向“动态”分配的数组的指针</span><br>    <span class="hljs-type">int</span> TableLen;        <span class="hljs-comment">//查找表的当前长度</span><br>&#125;SSTable;<br><span class="hljs-comment">//顺序查找</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST, ElemType key)</span>&#123;<br>    ST.elem[<span class="hljs-number">0</span>] = key;    <span class="hljs-comment">//设置&quot;哨兵&quot;</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=ST.TableLen; ST.elem[i]!=key; --i)&#123;<span class="hljs-comment">//从后往前找，不用判断越界</span><br>        <span class="hljs-keyword">return</span> i;        <span class="hljs-comment">//查找成功，则返回元素下标；查找失败，则返回0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、查找效率分析"><a href="#三、查找效率分析" class="headerlink" title="三、查找效率分析"></a>三、查找效率分析</h3><p><code>查找成功</code>：$$ASL_{成功}&#x3D;\frac{1}{n}+\frac{2}{n}+\cdots+\frac{n}{n}&#x3D;\frac{n+1}{2}$$，时间复杂度&#x3D;$$O(n)$$</p><p><code>查找成功</code>：$$ASL_{失败}&#x3D;n+1$$，时间复杂度&#x3D;$$O(n)$$</p><p>则，<code>时间复杂度</code>&#x3D;$$O(n)$$</p><h3 id="四、顺序查找的优化"><a href="#四、顺序查找的优化" class="headerlink" title="四、顺序查找的优化"></a>四、顺序查找的优化</h3><p>若查找表是<code>有序表</code>，可<code>优化查找失败</code>的ASL</p><p>若查找元素的<code>查找概率不同</code>，将<code>概率高的放前面</code>排序，可<code>优化查找成功</code>的ASL</p><!----------------------------------------------------------------------------------><h2 id="折半查找——Binary-Search"><a href="#折半查找——Binary-Search" class="headerlink" title="折半查找——Binary Search"></a>折半查找——Binary Search</h2><h3 id="一、折半查找的定义"><a href="#一、折半查找的定义" class="headerlink" title="一、折半查找的定义"></a>一、折半查找的定义</h3><p><code>折半查找</code>，又叫<code>二分查找</code>。仅适用于<code>有序的顺序表</code>。</p><h3 id="二、折半查找的实现"><a href="#二、折半查找的实现" class="headerlink" title="二、折半查找的实现"></a>二、折半查找的实现</h3><p><code>算法思想</code>：每次从中间分，判断自己是哪一半</p><p>普通代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//查找表的数据结构（动态分配的顺序表）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *elem;      <span class="hljs-comment">//指向“动态”分配的数组的指针</span><br>    <span class="hljs-type">int</span> TableLen;        <span class="hljs-comment">//查找表的当前长度</span><br>&#125;SSTable;<br><span class="hljs-comment">//折半查找</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Binary_Search</span><span class="hljs-params">(SSTable L, ElemType key)</span>&#123;<br>    <span class="hljs-type">int</span> low =<span class="hljs-number">0</span>, high = L.TableLen<span class="hljs-number">-1</span>, mid;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        mid = (low + high)/<span class="hljs-number">2</span>;           <span class="hljs-comment">//取中间值</span><br>        <span class="hljs-keyword">if</span>(L.elem[mid] == key)&#123;<br>            <span class="hljs-keyword">return</span> mid;                 <span class="hljs-comment">//查找成功，则返回所在位置</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(L.elem[mid] &gt; key)&#123;<br>            high = mid - <span class="hljs-number">1</span>;             <span class="hljs-comment">//从前半部分继续查</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            low = mid + <span class="hljs-number">1</span>;              <span class="hljs-comment">//从后半部分继续查</span><br>        &#125;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                          <span class="hljs-comment">//查找失败，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、查找效率分析-1"><a href="#三、查找效率分析-1" class="headerlink" title="三、查找效率分析"></a>三、查找效率分析</h3><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638256115837.png" alt="uTools_1638256115837"></p><h3 id="四、折半查找判定树的构造"><a href="#四、折半查找判定树的构造" class="headerlink" title="四、折半查找判定树的构造"></a>四、折半查找判定树的构造</h3><h4 id="构造："><a href="#构造：" class="headerlink" title="构造："></a>构造：</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638256209356.png" alt="uTools_1638256209356"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638256305668.png" alt="uTools_1638256305668"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638256324365.png" alt="uTools_1638256324365"></p><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638256454841.png" alt="uTools_1638256454841"></p><p>查找表有n个关键字，则失败结点有n+1个</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638256551359.png" alt="uTools_1638256551359"></p><p>与<code>折半查找判定树</code>的高度h有关。高度越小，查找效率越高</p><p>最好情况，平均查找长度&#x3D;$$O(log_2n)$$</p><p>最坏情况，平均查找长度&#x3D;$$O(n)$$</p><p>则<code>时间复杂度</code>&#x3D;$$O(log_2n)$$</p><!----------------------------------------------------------------------------------><h2 id="分块查找——Block-Search"><a href="#分块查找——Block-Search" class="headerlink" title="分块查找——Block Search"></a>分块查找——Block Search</h2><h3 id="一、分块查找的定义"><a href="#一、分块查找的定义" class="headerlink" title="一、分块查找的定义"></a>一、分块查找的定义</h3><p><code>分块查找</code>，又叫<code>索引顺序查找</code>。</p><h3 id="二、折半查找的实现-1"><a href="#二、折半查找的实现-1" class="headerlink" title="二、折半查找的实现"></a>二、折半查找的实现</h3><p><code>算法思想</code>：用一个<code>索引表</code>给数据归类。</p><p>算法过程：<br>①在<code>索引表</code>中确定待查记录所属的分块（<code>可顺序、可折半</code>）<br>②在<code>块内顺序查找</code></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638257539381.png" alt="uTools_1638257539381"></p><h4 id="用折半查找索引表："><a href="#用折半查找索引表：" class="headerlink" title="用折半查找索引表："></a>用折半查找索引表：</h4><p>若索引表中不包含目标关键字，则折半查找索引表<code>最终停在low&gt;high</code>，要<code>在low所指分块中查找</code></p><h3 id="三、查找效率分析-2"><a href="#三、查找效率分析-2" class="headerlink" title="三、查找效率分析"></a>三、查找效率分析</h3><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638258212238.png" alt="uTools_1638258212238"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638258279430.png" alt="uTools_1638258279430"></p><h3 id="四、分块查找的优化"><a href="#四、分块查找的优化" class="headerlink" title="四、分块查找的优化"></a>四、分块查找的优化</h3><p>上面的分块查找对插入删除不友好。</p><p>改进：索引表为顺序表，查找表为链表。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638258852038.jpg" alt="1638258852038"></p><!----------------------------------------------------------------------------------><h2 id="B树——B-Tree"><a href="#B树——B-Tree" class="headerlink" title="B树——B-Tree"></a>B树——B-Tree</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638266668727.png" alt="uTools_1638266668727"></p><h3 id="一、B树的定义"><a href="#一、B树的定义" class="headerlink" title="一、B树的定义"></a>一、B树的定义</h3><p><code>B树</code>，又名<code>多路平衡查找树</code>（<code>m叉查找树</code>）</p><p>数据库索引技术里大量使用者B树和B+树的数据结构.</p><p>B树是由<code>二叉排序树</code>升级为<code>m叉查找树</code></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638263634505.png" alt="uTools_1638263634505"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638263678360.png" alt="uTools_1638263678360"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638263378425.png" alt="1638263378425"></p><h4 id="核心特征"><a href="#核心特征" class="headerlink" title="核心特征"></a>核心特征</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638263546216.png" alt="uTools_1638263546216"></p><h3 id="二、B树的实现"><a href="#二、B树的实现" class="headerlink" title="二、B树的实现"></a>二、B树的实现</h3><h4 id="二叉排序树的类型表述（与二叉树一样）（二叉树的链式存储）"><a href="#二叉排序树的类型表述（与二叉树一样）（二叉树的链式存储）" class="headerlink" title="二叉排序树的类型表述（与二叉树一样）（二叉树的链式存储）"></a>二叉排序树的类型表述（与二叉树一样）（二叉树的链式存储）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br><span class="hljs-type">int</span> data;                   <span class="hljs-comment">//数据域</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchide</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">//左、右孩子指针</span><br>&#125;BSTNode, *BSTree;<br></code></pre></td></tr></table></figure><h4 id="B树的类型表述（m叉查找树）"><a href="#B树的类型表述（m叉查找树）" class="headerlink" title="B树的类型表述（m叉查找树）"></a>B树的类型表述（m叉查找树）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br><span class="hljs-type">int</span> datas[m<span class="hljs-number">-1</span>];                   <span class="hljs-comment">//zui</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">child</span>[<span class="hljs-title">m</span>];</span>         <span class="hljs-comment">//左、右孩子指针</span><br>&#125;BSTNode, *BSTree;<br></code></pre></td></tr></table></figure><h4 id="5叉查找树"><a href="#5叉查找树" class="headerlink" title="5叉查找树"></a>5叉查找树</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638262837463.png" alt="uTools_1638262837463"></p><h3 id="三、查找效率分析-3"><a href="#三、查找效率分析-3" class="headerlink" title="三、查找效率分析"></a>三、查找效率分析</h3><h4 id="保证查找效率："><a href="#保证查找效率：" class="headerlink" title="保证查找效率："></a>保证查找效率：</h4><p>每个结点的关键字太少，导致树变高，查找效率就会下降。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638262966104.png" alt="uTools_1638262966104"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638263106933.png" alt="uTools_1638263106933"></p><h4 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h4><p>最小高度：</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638263978037.png" alt="uTools_1638263978037"></p><p>最大高度：</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638264247752.png" alt="uTools_1638264247752"></p><p>综上，高度为：</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638264294898.png" alt="uTools_1638264294898"></p><h3 id="四、B树的插入"><a href="#四、B树的插入" class="headerlink" title="四、B树的插入"></a>四、B树的插入</h3><p>插入满一个结点后，从中间拆开，让中间位置（$$\lceil m&#x2F;2 \rceil$$）向上产生父结点，两边成为其孩子结点，依次类推</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/290047064066682.png" alt="B tree"></p><p><img src="https://files.cnblogs.com/yangecnu/btreebuild.gif" alt="img"></p><h3 id="五、B树的删除"><a href="#五、B树的删除" class="headerlink" title="五、B树的删除"></a>五、B树的删除</h3><p>情况一：删除<code>非终端结点</code>中的关键字</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638265769766.png" alt="1638265769766"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638265769770.png" alt="1638265769770"></p><p>情况一：删除<code>终端结点</code>中的关键字</p><p>①删除33时右边结点够借：</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638265769762.png" alt="1638265769762"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638265769749.jpg" alt="1638265769749"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638265769758.png" alt="1638265769758"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638265769753.png" alt="1638265769753"></p><p>②删除49时，右边的结点不够借：</p><p>解决方法：将<code>父结点中夹的关键字</code>取下与左右孩子<code>合并</code>。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638265769745.jpg" alt="1638265769745"></p><!----------------------------------------------------------------------------------><h2 id="B-树——B-Plus-Tree"><a href="#B-树——B-Plus-Tree" class="headerlink" title="B+树——B-Plus-Tree"></a>B+树——B-Plus-Tree</h2><h3 id="一、B树的定义-1"><a href="#一、B树的定义-1" class="headerlink" title="一、B树的定义"></a>一、B树的定义</h3><p><code>B+树</code>，又名<code>多级分块查找</code>。</p><p>数据库索引技术里大量使用者B树和B+树的数据结构.</p><p>B+树是由<code>分块查找</code>升级为<code>查找树</code></p><p>B树任何一层都可以找到，因为每一层都是数据<br>而B+树除叶子结点外，其余都是分类，只有最底层才会指向数据，必须找到最底层才能知道是否成功。</p><p>B+树有两种查找方式：①分块查找：从根结点查 ②顺序查找：从P开始横着查。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638279630033.png" alt="uTools_1638279630033"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638279791118.png" alt="uTools_1638279791118"></p><h3 id="二、B-树的实现"><a href="#二、B-树的实现" class="headerlink" title="二、B+树的实现"></a>二、B+树的实现</h3><p>无</p><h3 id="三、查找效率分析-4"><a href="#三、查找效率分析-4" class="headerlink" title="三、查找效率分析"></a>三、查找效率分析</h3><p>与B树一样</p><h3 id="四、B-树的插入"><a href="#四、B-树的插入" class="headerlink" title="四、B+树的插入"></a>四、B+树的插入</h3><p><img src="https://images0.cnblogs.com/blog/94031/201403/290050048129679.png" alt="B Plus tree"></p><p><img src="https://files.cnblogs.com/yangecnu/Bplustreebuild.gif" alt="img"></p><h3 id="五、B-树的删除"><a href="#五、B-树的删除" class="headerlink" title="五、B+树的删除"></a>五、B+树的删除</h3><p>与B树一样</p><h3 id="六、B树与B-树的对比"><a href="#六、B树与B-树的对比" class="headerlink" title="六、B树与B+树的对比"></a>六、B树与B+树的对比</h3><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638280509471.jpg" alt="1638280509471"></p><!----------------------------------------------------------------------------------><h2 id="散列查找-哈希查找-——Hash-Search"><a href="#散列查找-哈希查找-——Hash-Search" class="headerlink" title="散列查找(哈希查找)——Hash Search"></a>散列查找(哈希查找)——Hash Search</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638349184596.png" alt="uTools_1638349184596"></p><h3 id="一、哈希查找的定义"><a href="#一、哈希查找的定义" class="headerlink" title="一、哈希查找的定义"></a>一、哈希查找的定义</h3><p><code>散列表</code>（Hash Table），又名<code>哈希表</code>，是一种数据结构。</p><p><code>特点</code>：数据元素的<code>关键字与其存储地址直接相关</code>。</p><p>通过<code>散列函数（哈希函数）</code>将关键字与存储地址一一映射。</p><p>散列查找是典型的<code>“用空间换时间”的算法</code></p><p><code>装填因子α</code> &#x3D; 表中记录个数&#x2F;散列表表长</p><p><code>查找效率</code>：取决于<code>散列函数</code>、<code>处理冲突的方法</code>、<code>装填因子α</code></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638281466946.jpg" alt="1638281466946"></p><h4 id="处理冲突的方法——拉链法"><a href="#处理冲突的方法——拉链法" class="headerlink" title="处理冲突的方法——拉链法"></a>处理冲突的方法——拉链法</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638349467195.png" alt="uTools_1638349467195"></p><h3 id="二、常见的散列函数（哈希函数）"><a href="#二、常见的散列函数（哈希函数）" class="headerlink" title="二、常见的散列函数（哈希函数）"></a>二、常见的散列函数（哈希函数）</h3><p>冲突是由散列函数导致的，<code>冲突越多，查找效率越低</code></p><p>散列函数的设计目的：让不同的关键字的冲突尽可能少。</p><p>①除留余数法<br>②直接定址法<br>③数字分析法<br>④平方取中法</p><p>处理冲突的方法：以拉链法为主。</p><h4 id="1-除留余数法"><a href="#1-除留余数法" class="headerlink" title="1.除留余数法"></a>1.除留余数法</h4><p>$$H(key)&#x3D;key\mod{p}$$</p><p>除数p取法：散列表表长为m，取一个不大于m但最接近或等于m的<code>质数p</code></p><p>查找方法：当p&#x3D;13时，查找66，66%13&#x3D;1，则在a[1]下的链表中寻找。</p><p><code>查找效率分析</code>：</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638350479082.jpg" alt="1638350479082"></p><h4 id="2-直接定址法"><a href="#2-直接定址法" class="headerlink" title="2.直接定址法"></a>2.直接定址法</h4><p>$$H(key)&#x3D;key$$ 或 $$H(key)&#x3D;a*key+b$$ </p><p>这种计算最简单，适合<code>关键字分布连续</code>的情况</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638351041435.png" alt="uTools_1638351041435"></p><h4 id="3-数字分析法"><a href="#3-数字分析法" class="headerlink" title="3.数字分析法"></a>3.数字分析法</h4><p>选取数码<code>分布较为均匀的若干位</code>作为散列地址。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638351182580.png" alt="1638351182580"></p><h4 id="4-平方取中法"><a href="#4-平方取中法" class="headerlink" title="4.平方取中法"></a>4.平方取中法</h4><p>取<code>关键字的平方值的中间几位</code>作为散列地址。</p><p>具体取多少位要视实际情况而定。这种方法得到的<code>散列地址与关键字的每位都有关系</code>，因此使得<br>散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638351362463.png" alt="uTools_1638351362463"></p><h3 id="三、处理冲突的方法"><a href="#三、处理冲突的方法" class="headerlink" title="三、处理冲突的方法"></a>三、处理冲突的方法</h3><p>①拉链法<br>②开放定址法<br>③再散列法</p><h4 id="1-拉链法"><a href="#1-拉链法" class="headerlink" title="1.拉链法"></a>1.拉链法</h4><p>上面讲了</p><h4 id="2-开放定址法"><a href="#2-开放定址法" class="headerlink" title="2.开放定址法"></a>2.开放定址法</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638353226182.png" alt="uTools_1638353226182"></p><p><code>d的不同取法</code>：</p><h5 id="①线性探测法"><a href="#①线性探测法" class="headerlink" title="①线性探测法"></a>①线性探测法</h5><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638352055034.png" alt="uTools_1638352055034"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638352323225.png" alt="uTools_1638352323225"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638352359885.png" alt="uTools_1638352359885"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638352393458.png" alt="uTools_1638352393458"></p><h5 id="②平方探测法"><a href="#②平方探测法" class="headerlink" title="②平方探测法"></a>②平方探测法</h5><p>散列表长必须是$$4j+3$$</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638352677985.png" alt="uTools_1638352677985"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638352873925.png" alt="1638352873925"></p><h5 id="③伪随机序列法"><a href="#③伪随机序列法" class="headerlink" title="③伪随机序列法"></a>③伪随机序列法</h5><p>d取随机值</p><h4 id="3-再散列法"><a href="#3-再散列法" class="headerlink" title="3.再散列法"></a>3.再散列法</h4><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638353359841.png" alt="uTools_1638353359841"></p><!----------------------------------------------------------------------------------><h2 id="排序——Sort"><a href="#排序——Sort" class="headerlink" title="排序——Sort"></a>排序——Sort</h2><h3 id="常见排序算法与其时间复杂度："><a href="#常见排序算法与其时间复杂度：" class="headerlink" title="常见排序算法与其时间复杂度："></a>常见排序算法与其时间复杂度：</h3><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTgwNC84NDk1ODktMjAxODA0MDIxMzI1MzAzNDItOTgwMTIxNDA5LnBuZw.png" alt="aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTgwNC84NDk1ODktMjAxODA0MDIxMzI1MzAzNDItOTgwMTIxNDA5LnBuZw"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/20210408130104795.png" alt="20210408130104795"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638363129298.png" alt="1638363129298"></p><h3 id="一、排序的定义"><a href="#一、排序的定义" class="headerlink" title="一、排序的定义"></a>一、排序的定义</h3><p><code>排序</code>，就是重新排列表中的元素，使表中的元素满足<code>按关键字有序</code>的过程。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638362274133.png" alt="uTools_1638362274133"></p><h3 id="二、排序算法的应用"><a href="#二、排序算法的应用" class="headerlink" title="二、排序算法的应用"></a>二、排序算法的应用</h3><p>对数据进行大小排序</p><h3 id="三、排序的算法评价指标"><a href="#三、排序的算法评价指标" class="headerlink" title="三、排序的算法评价指标"></a>三、排序的算法评价指标</h3><p>时间复杂度、空间复杂度、<code>稳定性</code></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638362879122.png" alt="uTools_1638362879122"></p><h3 id="四、排序算法的分类"><a href="#四、排序算法的分类" class="headerlink" title="四、排序算法的分类"></a>四、排序算法的分类</h3><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/1638363129303.png" alt="1638363129303"></p><!----------------------------------------------------------------------------------><h2 id="插入排序——Insertion-Sort"><a href="#插入排序——Insertion-Sort" class="headerlink" title="插入排序——Insertion Sort"></a>插入排序——Insertion Sort</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638366099368.png" alt="uTools_1638366099368"></p><h3 id="一、算法思想："><a href="#一、算法思想：" class="headerlink" title="一、算法思想："></a>一、算法思想：</h3><p>每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="img"></p><h3 id="二、代码实现："><a href="#二、代码实现：" class="headerlink" title="二、代码实现："></a>二、代码实现：</h3><p>普通：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 直接插入排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i, j, temp;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;         <span class="hljs-comment">//讲个元素插入已排好的序列中</span><br>        <span class="hljs-keyword">if</span>(A[i]&lt;A[i<span class="hljs-number">-1</span>])&#123;        <span class="hljs-comment">//若A[i]的关键字小于前驱</span><br>            temp = A[i];        <span class="hljs-comment">//用temp暂存A[i]</span><br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span> &amp;&amp; A[j]&lt;temp; --j)&#123; <span class="hljs-comment">//检查所有前面已排好序的元素</span><br>                A[j+<span class="hljs-number">1</span>] = A[j];  <span class="hljs-comment">//所有大于temp的都后移</span><br>            &#125;<br>            A[j+<span class="hljs-number">1</span>] = temp;      <span class="hljs-comment">//复制到插入位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>带哨兵：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 直接插入排序（带哨兵）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;         <span class="hljs-comment">//讲个元素插入已排好的序列中</span><br>        <span class="hljs-keyword">if</span>(A[i]&lt;A[i<span class="hljs-number">-1</span>])&#123;        <span class="hljs-comment">//若A[i]的关键字小于前驱</span><br>            A[<span class="hljs-number">0</span>] = A[i];        <span class="hljs-comment">//复制为哨兵，A[0]作为哨兵</span><br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>; A[<span class="hljs-number">0</span>]&lt;A[j]; --j)&#123; <span class="hljs-comment">//从后往前查找待插入位置</span><br>                A[j+<span class="hljs-number">1</span>] = A[j];  <span class="hljs-comment">//所有大于A[0]的都后移</span><br>            &#125;<br>            A[j+<span class="hljs-number">1</span>] = A[<span class="hljs-number">0</span>];      <span class="hljs-comment">//复制到插入位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、算法效率分析"><a href="#三、算法效率分析" class="headerlink" title="三、算法效率分析"></a>三、算法效率分析</h3><p><code>空间复杂度</code>&#x3D;$$O(1)$$，因为需要的辅助变量为int i，j，temp，</p><p>时间复杂度:<br>最好情况&#x3D;$$n-1$$，时间复杂度&#x3D;$$O(n)$$<br>最坏情况&#x3D;$$2+3+\cdots+n+(n+1)&#x3D;\frac{n(n+3)}{2}$$，时间复杂度&#x3D;$$O(n^2)$$<br>平均<code>时间复杂度</code>&#x3D;$$O(n^2)$$</p><p>算法稳定性：<code>稳定</code></p><h3 id="四、优化——折半插入排序"><a href="#四、优化——折半插入排序" class="headerlink" title="四、优化——折半插入排序"></a>四、优化——折半插入排序</h3><p>折半查找找出插入的位置</p><p>当A[mid]&#x3D;A[0]时，将[mid，i-1]内的元素全部后移，并将A[0]复制到mid所在位置。</p><p>Low&gt;high时停止，将[low，i-1]内的元素全部后移，并将A[0]复制到low所在位置。</p><p>带哨兵：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 直接插入排序（带哨兵）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i, j, low，high，mid;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;         <span class="hljs-comment">//讲个元素插入已排好的序列中</span><br>        <span class="hljs-keyword">if</span>(A[i]&lt;A[i<span class="hljs-number">-1</span>])&#123;        <span class="hljs-comment">//若A[i]的关键字小于前驱</span><br>            A[<span class="hljs-number">0</span>] = A[i];        <span class="hljs-comment">//复制为哨兵，A[0]作为哨兵</span><br>            low = <span class="hljs-number">1</span>;<br>            high = i<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>                mid = (low+high)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(A[mid] &gt; A[<span class="hljs-number">0</span>]) high = mid - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>; j&gt;high+<span class="hljs-number">1</span>; --j)&#123; <span class="hljs-comment">//从后往前查找待插入位置</span><br>                A[j+<span class="hljs-number">1</span>] = A[j];  <span class="hljs-comment">//所有大于A[0]的都后移</span><br>            &#125;<br>            A[high+<span class="hljs-number">1</span>] = A[<span class="hljs-number">0</span>];      <span class="hljs-comment">//复制到插入位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 虽然对比关键字次数变少，但时间复杂度的数量级依然没变。</p><p><code>时间复杂度</code>&#x3D;$$O(n^2)$$</p><!----------------------------------------------------------------------------------><h2 id="希尔排序——Shell’s-Sort"><a href="#希尔排序——Shell’s-Sort" class="headerlink" title="希尔排序——Shell’s Sort"></a>希尔排序——Shell’s Sort</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638366303933.png" alt="uTools_1638366303933"></p><p><code>希尔排序</code>又叫<code>缩小增量排序</code>。</p><p>1959年Shell发明，第一个突破$$O(n^2)$$的排序算法，是<code>简单插入排序的改进版</code>。它与插入排序的不同之处在于，它会<code>优先比较距离较远的元素</code>。</p><h3 id="一、算法思想：-1"><a href="#一、算法思想：-1" class="headerlink" title="一、算法思想："></a>一、算法思想：</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><p><img src="https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif" alt="img"></p><h3 id="二、代码实现：-1"><a href="#二、代码实现：-1" class="headerlink" title="二、代码实现："></a>二、代码实现：</h3><p>在简单插入排序外加了<code>步长变化</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//希尔排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> d, i, j;<br>    <span class="hljs-keyword">for</span>(d=n/<span class="hljs-number">2</span>; d&gt;<span class="hljs-number">1</span>; d=d/<span class="hljs-number">2</span>)&#123;     <span class="hljs-comment">//步长变化</span><br>        <span class="hljs-keyword">for</span>(i=d+<span class="hljs-number">1</span>; i&lt;=n; ++i)&#123;  <span class="hljs-comment">//讲个元素插入已排好的序列中</span><br>        <span class="hljs-keyword">if</span>(A[i]&lt;A[i-d])&#123;        <span class="hljs-comment">//若A[i]的关键字小于前驱</span><br>            A[<span class="hljs-number">0</span>] = A[i];        <span class="hljs-comment">//复制为哨兵，A[0]作为哨兵</span><br>            <span class="hljs-keyword">for</span>(j=i-d; j&gt;<span class="hljs-number">0</span> &amp;&amp; A[<span class="hljs-number">0</span>]&lt;A[j]; j-=d)&#123; <span class="hljs-comment">//从后往前查找待插入位置</span><br>                A[j+d] = A[j];  <span class="hljs-comment">//所有大于A[0]的都后移</span><br>            &#125;<br>            A[j+d] = A[<span class="hljs-number">0</span>];      <span class="hljs-comment">//复制到插入位置</span><br>        &#125;<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、算法效率分析-1"><a href="#三、算法效率分析-1" class="headerlink" title="三、算法效率分析"></a>三、算法效率分析</h3><p><code>空间复杂度</code>&#x3D;$$O(1)$$，因为需要的辅助变量为int d，i，j，</p><p>时间复杂度:<br>无法计算，<code>时间复杂度</code>大概为&#x3D;$$O(n^{1.3})$$</p><p>算法稳定性：<code>不稳定</code></p><p><code>仅适用于顺序表，不适用于链表</code></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638367624883.png" alt="uTools_1638367624883"></p><!----------------------------------------------------------------------------------><h2 id="冒泡排序——Bubble-Sort"><a href="#冒泡排序——Bubble-Sort" class="headerlink" title="冒泡排序——Bubble Sort"></a>冒泡排序——Bubble Sort</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638450353573.png" alt="uTools_1638450353573"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638449861667.png" alt="uTools_1638449861667"></p><p><code>冒泡排序</code>是一种简单的排序算法。它重复地走访过要排序的数列，<code>一次比较两个元素</code>，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为<code>越小的元素会经由交换慢慢“浮”到数列的顶端</code>。 </p><p><code>确定最小数或最大数的位置</code></p><h3 id="一、算法思想：-2"><a href="#一、算法思想：-2" class="headerlink" title="一、算法思想："></a>一、算法思想：</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="img"></p><h3 id="二、代码实现：-2"><a href="#二、代码实现：-2" class="headerlink" title="二、代码实现："></a>二、代码实现：</h3><p>从后往前两两比较，逆序则交换，比较完可将最小的放前面，将第一个去除，比较剩下的，再确定次小，以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//交换</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">((<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)&#123;</span><br><span class="hljs-params"><span class="hljs-type">int</span> temp = a;</span><br><span class="hljs-params">    a = b;</span><br><span class="hljs-params">    b = temp;</span><br><span class="hljs-params">&#125;</span><br><span class="hljs-params"><span class="hljs-comment">//冒泡排序</span></span><br><span class="hljs-params"><span class="hljs-type">void</span> BubbleSort(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n)&#123;</span><br><span class="hljs-params">    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;</span><br><span class="hljs-params">        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;</span><br><span class="hljs-params">        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>; j&gt;i; j--)     <span class="hljs-comment">//一趟冒泡排序：从后往前两两比较</span></span><br><span class="hljs-params">            <span class="hljs-keyword">if</span>(A[j<span class="hljs-number">-1</span>]&gt;A[j])&#123;         <span class="hljs-comment">//若逆序</span></span><br><span class="hljs-params">                swqp(A[j<span class="hljs-number">-1</span>],A[j]);   <span class="hljs-comment">//则交换</span></span><br><span class="hljs-params">                flag = <span class="hljs-literal">true</span>;</span><br><span class="hljs-params">            &#125;</span><br><span class="hljs-params">        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;</span><br><span class="hljs-params">            <span class="hljs-keyword">return</span>;          <span class="hljs-comment">//本趟遍历后没有发生交换，说明表已经有序</span></span><br><span class="hljs-params">        &#125;</span><br><span class="hljs-params">    &#125;</span><br><span class="hljs-params">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="三、算法效率分析-2"><a href="#三、算法效率分析-2" class="headerlink" title="三、算法效率分析"></a>三、算法效率分析</h3><p><code>空间复杂度</code>&#x3D;$$O(1)$$，因为需要的辅助变量为bool flag</p><p>时间复杂度:<br>最好情况&#x3D;$$n-1$$，时间复杂度&#x3D;$$O(n)$$<br>最坏情况&#x3D;$$(n-1)+(n-2)+\cdots+2+1&#x3D;\frac{n(n-1)}{2}$$，时间复杂度&#x3D;$$O(n^2)$$<br>平均<code>时间复杂度</code>&#x3D;$$O(n^2)$$</p><p>算法稳定性：<code>稳定</code></p><p>顺序表和链表都可以。</p><!----------------------------------------------------------------------------------><h2 id="快速排序——Quick-Sort"><a href="#快速排序——Quick-Sort" class="headerlink" title="快速排序——Quick Sort"></a>快速排序——Quick Sort</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638450353573.png" alt="uTools_1638450353573"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638451646054.png" alt="uTools_1638451646054"></p><p><code>快速排序</code>的基本思想：通过一趟排序将待排记录<code>分隔成独立的两部分</code>，其中一部分记录的关键字均比另一部分的关键字小，则<code>可分别对这两部分记录继续进行排序</code>，以达到整个序列有序。</p><p><code>确定中间数的位置</code></p><h3 id="一、算法思想：-3"><a href="#一、算法思想：-3" class="headerlink" title="一、算法思想："></a>一、算法思想：</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于</li></ul><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" alt="img"></p><h3 id="二、代码实现：-3"><a href="#二、代码实现：-3" class="headerlink" title="二、代码实现："></a>二、代码实现：</h3><p>将第一个作为枢轴，后面的元素与枢轴比较，一此low，一high比较，low的大则放到high处，high的小则放到low处，直到low&#x3D;high，找到枢轴位置。</p><p>按枢轴分成两部分，分别做上面的方法，以此类推（递归）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用第一个元素将待排序序列划分成左右两个部分</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Partition</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span>&#123;<br><span class="hljs-type">int</span> pivot = A[Low];    <span class="hljs-comment">//第一个元素作为枢轴</span><br>    <span class="hljs-keyword">while</span>(low &lt; high)&#123;     <span class="hljs-comment">//用10w、high搜索枢轴的最终位置</span><br>        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=pivot ) --high;<br>        A[Low] = A[high];  <span class="hljs-comment">//比枢轴小的元素移动到左端</span><br>        <span class="hljs-keyword">while</span>(low&lt;high &amp;&amp; A[Low]&lt;=pivot）++low;<br>        A[high] = A[low];  <span class="hljs-comment">//比枢轴大的元素移动到右端</span><br>&#125;<br>A[low] = pivot;        <span class="hljs-comment">//枢轴元素存放到最终位置</span><br><span class="hljs-keyword">return</span> low;            <span class="hljs-comment">//返回存放枢轴的最终位置</span><br>&#125;<br><span class="hljs-comment">//快速排序</span><br><span class="hljs-type">void</span> QuickSort(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)&#123;<br><span class="hljs-keyword">if</span>(low&lt;high)&#123;  <span class="hljs-comment">//递归跳出的条件</span><br><span class="hljs-type">int</span> pivotpos =Partition(A,Low,high); <span class="hljs-comment">//划分</span><br>QuickSort(A,low,pivotpos<span class="hljs-number">-1</span>);  <span class="hljs-comment">//划分左子表</span><br>QuickSort(A,pivotpos+<span class="hljs-number">1</span>,high); <span class="hljs-comment">//划分右子表</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、算法效率分析-3"><a href="#三、算法效率分析-3" class="headerlink" title="三、算法效率分析"></a>三、算法效率分析</h3><p>与递归深度有关</p><p><code>空间复杂度</code>&#x3D;$$O(递归深度)$$<br>最好空间复杂度&#x3D;$$O(log_2n)$$<br>最坏 空间复杂度&#x3D;$$O(n)$$</p><p>时间复杂度&#x3D;$$O(n*递归深度)$$<br>最好时间复杂度&#x3D;$$O(nlog_2n)$$<br>最坏时间复杂度&#x3D;$$O(n^2)$$<br>平均<code>时间复杂度</code>&#x3D;$$O(nlog_2n)$$</p><p>算法稳定性：<code>不稳定</code></p><!----------------------------------------------------------------------------------><h2 id="简单选择排序——Select-Sort"><a href="#简单选择排序——Select-Sort" class="headerlink" title="简单选择排序——Select Sort"></a>简单选择排序——Select Sort</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638453625935.png" alt="uTools_1638453625935"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638453702968.png" alt="uTools_1638453702968"></p><p><code>选择排序</code>是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h3 id="一、算法思想：-4"><a href="#一、算法思想：-4" class="headerlink" title="一、算法思想："></a>一、算法思想：</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="img"></p><h3 id="二、代码实现：-4"><a href="#二、代码实现：-4" class="headerlink" title="二、代码实现："></a>二、代码实现：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//简单选择排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SelectSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n<span class="hljs-number">-1</span>; i++)&#123;<br>        <span class="hljs-type">int</span> min = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(A[j]&lt;A[min]) min = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min!=i) swap(A[i],A[min]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、算法效率分析-4"><a href="#三、算法效率分析-4" class="headerlink" title="三、算法效率分析"></a>三、算法效率分析</h3><p><code>空间复杂度</code>&#x3D;$$O(1)$$，因为需要的辅助变量为int i，j</p><p>时间复杂度&#x3D;$$(n-1)+(n-2)+\cdots+2+1&#x3D;\frac{n(n-1)}{2}$$，<code>时间复杂度</code>&#x3D;$$O(n^2)$$</p><p>算法稳定性：<code>稳定</code></p><p>顺序表和链表都可以</p><!----------------------------------------------------------------------------------><h2 id="堆排序——Heap-Sort"><a href="#堆排序——Heap-Sort" class="headerlink" title="堆排序——Heap Sort"></a>堆排序——Heap Sort</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/raw/main/images/uTools_1638453625935.png" alt="uTools_1638453625935"></p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/raw/main/images/uTools_1638518610172.png" alt="uTools_1638518610172"></p><p><code>堆排序</code>是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/raw/main/images/uTools_1638519013491.png" alt="uTools_1638519013491"></p><p>大根堆：完全二叉树中，根&gt;&#x3D;左、右。</p><p>小根堆：完全二叉树中，根&lt;&#x3D;左、右。</p><h3 id="一、算法思想：-5"><a href="#一、算法思想：-5" class="headerlink" title="一、算法思想："></a>一、算法思想：</h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif" alt="img"></p><h3 id="二、代码实现：-5"><a href="#二、代码实现：-5" class="headerlink" title="二、代码实现："></a>二、代码实现：</h3><h4 id="1-先建立大根堆："><a href="#1-先建立大根堆：" class="headerlink" title="1.先建立大根堆："></a>1.先建立大根堆：</h4><p>①建立大根堆，只需检查所有非终端结点是否满足大根堆要求。顺序存储的二叉树中非终端结点编号为$$i&lt;\lfloor n&#x2F;2 \rfloor$$<br>②从$$i&#x3D;\lfloor n&#x2F;2 \rfloor$$开始，从后往前处理非终端结点，判断第i个结点与它的孩子结点2i，2i+1是否满足大根堆要求。不满足，则根与最大的孩子互换。<br>③换了的孩子还要继续判断与它的孩子是否满足，依次往下判断。直到没有可以换的。（<code>小元素不断下坠</code>）</p><h4 id="2-基于大根堆进行排序"><a href="#2-基于大根堆进行排序" class="headerlink" title="2.基于大根堆进行排序"></a>2.基于大根堆进行排序</h4><p>①大根堆可知最前面是最大的，则交换最前与最后元素<br>②排除最后元素，重新建立大根堆，建好后再将第一个元素与最后一个元素交换（排除最后已确定的元素），以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//建立大根堆（处理所有的非终端结点）(初始调整范围)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BuildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> len)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len/<span class="hljs-number">2</span>; i&gt;<span class="hljs-number">0</span>; i--)&#123;<br>        HeadAdjust(A,i,len);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//将以k为根的子树调整为大根堆（调整方法：下坠）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HeadAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> k;<span class="hljs-type">int</span> len)</span>&#123;<br>    A[<span class="hljs-number">0</span>]=A[k];                           <span class="hljs-comment">//k指向根结点，用A[0]暂存</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>*k; i&lt;=len; i*=<span class="hljs-number">2</span>)&#123;        <span class="hljs-comment">//沿key较大的子结点下下筛选</span><br>        <span class="hljs-keyword">if</span>(i&lt;len &amp;&amp; A[i]&lt;A[i+<span class="hljs-number">1</span>]) i++;    <span class="hljs-comment">//右孩子更大，则i++</span><br>        <span class="hljs-keyword">if</span>(A[<span class="hljs-number">0</span>] &gt;= A[i]) <span class="hljs-keyword">break</span>;          <span class="hljs-comment">//满足根&gt;左、右孩子</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            A[k] = A[i];                 <span class="hljs-comment">//将大的孩子成为根</span><br>            k = i;                       <span class="hljs-comment">//k指向新的根</span><br>        &#125;<br>    &#125;<br>    A[k] = A[<span class="hljs-number">0</span>];                         <span class="hljs-comment">//被筛选结点的值放入最终位置</span><br>&#125;<br><span class="hljs-comment">//堆排序的完整逻辑</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HeapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> len)</span>&#123;<br>    BuildMaxHeap(A,len);        <span class="hljs-comment">//初始建立大根堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len; i&gt;<span class="hljs-number">1</span>; i--)&#123;   <span class="hljs-comment">//找n-1次最大元素</span><br>        swap(A[i],A[<span class="hljs-number">1</span>]);        <span class="hljs-comment">//堆顶元素与堆顶元素交换</span><br>    HeadAdjust(A,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);    <span class="hljs-comment">//交换后只有A[1]不满足大根堆要求，则调整A[1]即可</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、算法效率分析-5"><a href="#三、算法效率分析-5" class="headerlink" title="三、算法效率分析"></a>三、算法效率分析</h3><p><code>空间复杂度</code>&#x3D;$$O(1)$$</p><p>时间复杂度：</p><p>建堆：<br>一个结点，每下坠一层，最多只对比关键字两次。<br>树高为$$h$$，在i层的结点最多下坠$$h-i$$层，则对比关键字$$2*(h-i)$$<br>第一层对比$$2^0<em>2</em>(h-1)$$，第二层对比$$2^1<em>2</em>(h-2)$$，则第i层对比$$2^{i-1}<em>2</em>(h-i)$$，共h-1层<br>求和后不超过$$4n$$，则<code>建堆的时间复杂度</code>&#x3D;$$O(n)$$</p><p>下坠：<br>n-1次下坠，每次最多下h层，因$$h&#x3D;log_2n$$，则<code>下坠的时间复杂度</code>&#x3D;$$O(nlog_2n)$$</p><p>则堆排序的<code>时间复杂度</code>&#x3D;$$O(n)$$+$$O(nlog_2n)$$&#x3D;$$O(nlog_2n)$$</p><p>算法稳定性：<code>不稳定</code></p><!----------------------------------------------------------------------------------><h2 id="归并排序——Merge-Sort"><a href="#归并排序——Merge-Sort" class="headerlink" title="归并排序——Merge Sort"></a>归并排序——Merge Sort</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/raw/main/images/uTools_1638535460811.png" alt="uTools_1638535460811"></p><p><code>归并排序</code>是建立在归并操作上的一种有效的排序算法。该算法是采用<code>分治法</code>（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p><p>归并：把两个或多个已经有序的序列合并成一个。</p><p>m路归并：将m个有序的序列合并成一个，每选出一个元素需要对比关键字m-1次。</p><p>2路归并：</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/raw/main/images/uTools_1638535201796.png" alt="uTools_1638535201796"></p><h3 id="一、算法思想：-6"><a href="#一、算法思想：-6" class="headerlink" title="一、算法思想："></a>一、算法思想：</h3><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" alt="img"></p><h3 id="二、代码实现：-6"><a href="#二、代码实现：-6" class="headerlink" title="二、代码实现："></a>二、代码实现：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *B = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">//辅助数组B</span><br><span class="hljs-comment">//将两个有序数组归并（A[low...mid]和A[mid+1...high]各自有序，将两个部分归并）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> high)</span>&#123;<br>    <span class="hljs-type">int</span> i,j,k;<br>    <span class="hljs-keyword">for</span>(k=low; k&lt;=high; k++)&#123;<br>        B[k] = A[k];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=low,j=mid+<span class="hljs-number">1</span>,k=i; i&lt;=mid&amp;&amp;j&lt;=high; k++)&#123;<br>        <span class="hljs-keyword">if</span>(B[i]&lt;=B[j]) A[k] = B[i++];     <span class="hljs-comment">//将较小的复制到A中，先赋值，再将指针后移。</span><br>        <span class="hljs-keyword">else</span> A[k] = B[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;=mid) A[k++] = B[i++];    <span class="hljs-comment">//先赋值，再将指针后移。</span><br>    <span class="hljs-keyword">while</span>(j&lt;=high) A[k++] = B[j++];    <span class="hljs-comment">//先赋值，再将指针后移。</span><br>&#125;<br><span class="hljs-comment">//归并排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span>&#123;<br>    <span class="hljs-keyword">if</span>(low&lt;high)&#123;<br>        <span class="hljs-type">int</span> mid = (low+high)/<span class="hljs-number">2</span>;   <span class="hljs-comment">//从中间划分</span><br>        MergeSort(A,low,mid);     <span class="hljs-comment">//对左半部分归并排序</span><br>        MergeSort(A,mid+<span class="hljs-number">1</span>,high);  <span class="hljs-comment">//对右半部分归并排序</span><br>        Merge(A,low,mid,high);    <span class="hljs-comment">//归并</span><br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、算法效率分析-6"><a href="#三、算法效率分析-6" class="headerlink" title="三、算法效率分析"></a>三、算法效率分析</h3><p><code>空间复杂度</code>&#x3D;$$O(n)$$，因为需要的辅助数组B</p><p>时间复杂度：<br>n个元素进行二路归并，需进行$$\lceil log_2n \rceil$$趟<br>每趟归并的时间复杂度&#x3D;$$O(n)$$<br><code>时间复杂度</code>&#x3D;$$O(nlog_2n)$$</p><p>算法稳定性：<code>稳定</code></p><p>顺序表和链表都可以。</p><!----------------------------------------------------------------------------------><h2 id="基数排序——Radix-Sort"><a href="#基数排序——Radix-Sort" class="headerlink" title="基数排序——Radix Sort"></a>基数排序——Radix Sort</h2><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638539983688.png" alt="uTools_1638539983688"></p><p><code>基数排序</code>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><p><code>r为基数</code>，基数是每一位可以取的数的范围，例如10进制的一位数可以取0~9，则<code>十进制的基数r=10</code>。</p><p>d为关键字个数，也是趟数，例如<code>10进制的一位数为一个d</code>。</p><p>n为元素个数</p><p>基数排序擅长树立d小，r小，n大的元素序列进行排序。</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638540152741.png" alt="uTools_1638540152741"></p><h3 id="一、算法思想：-7"><a href="#一、算法思想：-7" class="headerlink" title="一、算法思想："></a>一、算法思想：</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的</li></ul><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015232453668-1397662527.gif" alt="img"></p><h3 id="二、代码实现：-7"><a href="#二、代码实现：-7" class="headerlink" title="二、代码实现："></a>二、代码实现：</h3><p>需一个辅助链队列来实现</p><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638540352134.png" alt="uTools_1638540352134"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *B = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">//辅助数组B</span><br><span class="hljs-comment">//将两个有序数组归并（A[low...mid]和A[mid+1...high]各自有序，将两个部分归并）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> high)</span>&#123;<br>    <span class="hljs-type">int</span> i,j,k;<br>    <span class="hljs-keyword">for</span>(k=low; k&lt;=high; k++)&#123;<br>        B[k] = A[k];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=low,j=mid+<span class="hljs-number">1</span>,k=i; i&lt;=mid&amp;&amp;j&lt;=high; k++)&#123;<br>        <span class="hljs-keyword">if</span>(B[i]&lt;=B[j]) A[k] = B[i++];     <span class="hljs-comment">//将较小的复制到A中，先赋值，再将指针后移。</span><br>        <span class="hljs-keyword">else</span> A[k] = B[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j&lt;=mid) A[k++] = B[i++];    <span class="hljs-comment">//先赋值，再将指针后移。</span><br>    <span class="hljs-keyword">while</span>(j&lt;=high) A[k++] = B[j++];    <span class="hljs-comment">//先赋值，再将指针后移。</span><br>&#125;<br><span class="hljs-comment">//归并排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span>&#123;<br>    <span class="hljs-keyword">if</span>(low&lt;high)&#123;<br>        <span class="hljs-type">int</span> mid = (low+high)/<span class="hljs-number">2</span>;   <span class="hljs-comment">//从中间划分</span><br>        MergeSort(A,low,mid);     <span class="hljs-comment">//对左半部分归并排序</span><br>        MergeSort(A,mid+<span class="hljs-number">1</span>,high);  <span class="hljs-comment">//对右半部分归并排序</span><br>        Merge(A,low,mid,high);    <span class="hljs-comment">//归并</span><br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、算法效率分析-7"><a href="#三、算法效率分析-7" class="headerlink" title="三、算法效率分析"></a>三、算法效率分析</h3><p>空间、时间复杂度<code>取决于基数r</code></p><p><code>空间复杂度</code>&#x3D;$$O(r)$$，<br>因为需要r个辅助队列，链队列是增加指针域，则每个链队列的空间复杂度&#x3D;$$O(1)$$</p><p><code>时间复杂度</code>&#x3D;$$O(d(n+r))$$</p><p>算法稳定性：<code>稳定</code></p><h3 id="四、基数排序的应用"><a href="#四、基数排序的应用" class="headerlink" title="四、基数排序的应用"></a>四、基数排序的应用</h3><p><img src="https://github.com/oxyanyano/2022-WangDao-CS-DS-Notes/blob/main/images/uTools_1638541177922.png" alt="uTools_1638541177922"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派基础配置及常见问题</title>
    <link href="/2023/08/25/raspberry_one/"/>
    <url>/2023/08/25/raspberry_one/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一、安装树莓派系统及配置树莓派"><a href="#一、安装树莓派系统及配置树莓派" class="headerlink" title="一、安装树莓派系统及配置树莓派"></a>一、安装树莓派系统及配置树莓派</h3><h4 id="下载树莓派系统"><a href="#下载树莓派系统" class="headerlink" title="下载树莓派系统"></a>下载树莓派系统</h4><h5>Raspberry Pi OS（Raspbian）：</h5><h6>下载地址</h6><pre><code class="hljs">https://downloads.raspberrypi.org/raspios_armhf_latest</code></pre><h6>默认账号：</h6><p>&ensp;&ensp;<font size= 2 ><strong>Username</strong>: <code>pi</code> <strong>Password</strong>: <code>raspberry</code></font></p><h5>Ubuntu MATE for the Raspberry Pi：</h5><h6>下载地址：</h6><pre><code class="hljs">https://make.quwj.com/bookmark/334/go</code></pre><h6>默认账号：</h6><p>&ensp;&ensp; <font size= 2 ><strong>Username</strong>: <code>ubuntu</code>  <strong>Password</strong>:  <code>ubuntu</code></font></p><h5>Kali Linux for Pi：</h5><h6>下载地址：</h6><pre><code class="hljs">https://kali.download/arm-images/kali-2022.4/kali-linux-2022.4-raspberry-pi-armhf.img.xz（32位）https://kali.download/arm-images/kali-2022.4/kali-linux-2022.4-raspberry-pi-arm64.img.xz（64位）</code></pre><h4 id="下载格式化SD卡工具（SD-Card-Formatter），并格式化SD卡"><a href="#下载格式化SD卡工具（SD-Card-Formatter），并格式化SD卡" class="headerlink" title="下载格式化SD卡工具（SD Card Formatter），并格式化SD卡"></a>下载格式化SD卡工具（SD Card Formatter），并格式化SD卡</h4><h6>下载地址：</h6><pre><code class="hljs">     https://www.sdcard.org/</code></pre><p>下载安装完成后，插入SD卡，打开软件，点击“Format” 即可。</p><h4 id="下载系统烧录软件（Win32-Disk-Imager）"><a href="#下载系统烧录软件（Win32-Disk-Imager）" class="headerlink" title="下载系统烧录软件（Win32 Disk Imager）"></a>下载系统烧录软件（Win32 Disk Imager）</h4><h6>下载地址：</h6><pre><code class="hljs">    https://sourceforge.net/projects/win32diskimager/</code></pre><p>解压下载好的zip文件得到.img镜像文件然后选好系统文件，选择SD卡设备，点击“写入”。</p><h4 id="等待完成"><a href="#等待完成" class="headerlink" title="等待完成"></a>等待完成</h4><h4 id="树莓派新系统SSH连接被拒绝的解决方法"><a href="#树莓派新系统SSH连接被拒绝的解决方法" class="headerlink" title="树莓派新系统SSH连接被拒绝的解决方法"></a>树莓派新系统SSH连接被拒绝的解决方法</h4><p>把SD卡拔下来，在电脑下进入到根目录(boot)，新建一个名为ssh的空白文件。</p><h4 id="树莓派进行ssh连接"><a href="#树莓派进行ssh连接" class="headerlink" title="树莓派进行ssh连接"></a>树莓派进行ssh连接</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sudo</span> service ssh start    <span class="hljs-comment">#打开ssh服务</span><br><br>ssh [用户名]<span class="hljs-variable">@ip</span>地址 -p 端口号<br></code></pre></td></tr></table></figure><h4 id="Linux更换国内源"><a href="#Linux更换国内源" class="headerlink" title="Linux更换国内源"></a>Linux更换国内源</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>apt/sources.list<br><br>    deb https:<span class="hljs-regexp">//</span>xxxxxxxxxxxxxxxxx<br>    deb-src https:<span class="hljs-regexp">//</span>xxxxxxxxxxxxxx<br><br>sudo apt-get update &amp;&amp; apt-get upgrade<br><br>sudo apt-get dist-upgrade   <span class="hljs-comment">#重新安装未能安装的应用</span><br></code></pre></td></tr></table></figure><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sudo su    <span class="hljs-meta">#初始化密码可能为：toor</span><br><br>sudo passwd<br><br>[<span class="hljs-meta">sudo</span>] password <span class="hljs-keyword">for</span> xxx:<br><br>（输入新的root密码）<br><br>（确认密码）<br></code></pre></td></tr></table></figure><h3 id="二、树莓派3b-HDMI不能正常显示"><a href="#二、树莓派3b-HDMI不能正常显示" class="headerlink" title="二、树莓派3b HDMI不能正常显示"></a>二、树莓派3b HDMI不能正常显示</h3><p>&ensp;&ensp;与传统PC不同，树莓派使用<code>config</code>文件来代替传统PC中的BIOS界面，系统配置参数不是使用<code>BIOS（ Basic Input/Output System）</code>进行编辑和存储的，而是存储在一个名为<code>config.txt</code>的可选文本文件中，在ARM CPU和Linux被初始化之前，这是由GPU读取的。因此，它必须位于SD卡的第一个(引导)分区上，与引导代码一起。在 <code>bootcode.bin</code> 和 <code>start.elf</code> 文件的旁边。这个文件通常可以作为<code>/boot/config</code>访问，必须使用root进行编辑。</p><h4 id="将sd中的config-txt文件内容替换成"><a href="#将sd中的config-txt文件内容替换成" class="headerlink" title="将sd中的config.txt文件内容替换成"></a>将sd中的config.txt文件内容替换成</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">hdmi_force_hotplug</span>=<span class="hljs-number">1</span><br><br><span class="hljs-attr">config_hdmi_boost</span>=<span class="hljs-number">4</span><br><br><span class="hljs-attr">hdmi_group</span>=<span class="hljs-number">2</span><br><br><span class="hljs-attr">hdmi_mode</span>=<span class="hljs-number">9</span><br><br><span class="hljs-attr">hdmi_drive</span>=<span class="hljs-number">2</span><br><br><span class="hljs-attr">hdmi_ignore_edid</span>=<span class="hljs-number">0</span>xa5000080<br><br><span class="hljs-attr">disable_overscan</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="三、树莓派非官方系统解决-sudo-raspi-config-command-not-found-问题"><a href="#三、树莓派非官方系统解决-sudo-raspi-config-command-not-found-问题" class="headerlink" title="三、树莓派非官方系统解决 sudo: raspi-config: command not found 问题"></a>三、树莓派非官方系统解决 sudo: raspi-config: command not found 问题</h3><h4 id="手动下载deb包"><a href="#手动下载deb包" class="headerlink" title="手动下载deb包"></a>手动下载deb包</h4><pre><code class="hljs">wget http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/pool/main/r/raspi-config/raspi-config_20221214_all.deb</code></pre><h4 id="解决依赖问题"><a href="#解决依赖问题" class="headerlink" title="解决依赖问题"></a>解决依赖问题</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> apt install lua5.<span class="hljs-number">1</span> libatopology2 libfftw3-single3 libsamplerate0 alsa-utils<br></code></pre></td></tr></table></figure><h4 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo dpkg -<span class="hljs-selector-tag">i</span> raspi-config_20221214_all<span class="hljs-selector-class">.deb</span><br></code></pre></td></tr></table></figure><h4 id="运行raspi-config，需要sudo或以上权限"><a href="#运行raspi-config，需要sudo或以上权限" class="headerlink" title="运行raspi-config，需要sudo或以上权限"></a>运行raspi-config，需要sudo或以上权限</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo raspi-config<br></code></pre></td></tr></table></figure><h4 id="raspi-config能够运行的还有一个重要前提，boot分区已被正常挂载"><a href="#raspi-config能够运行的还有一个重要前提，boot分区已被正常挂载" class="headerlink" title="raspi-config能够运行的还有一个重要前提，boot分区已被正常挂载"></a>raspi-config能够运行的还有一个重要前提，boot分区已被正常挂载</h4><h5 id="（1）先查看一下boot分区所在设备号"><a href="#（1）先查看一下boot分区所在设备号" class="headerlink" title="（1）先查看一下boot分区所在设备号"></a>（1）先查看一下boot分区所在设备号</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fdisk -l</span><br></code></pre></td></tr></table></figure><h5 id="（2）-再把它挂载到-boot上-以下是示例，不一定是mmcblk0p6，需根据实际情况决定"><a href="#（2）-再把它挂载到-boot上-以下是示例，不一定是mmcblk0p6，需根据实际情况决定" class="headerlink" title="（2） 再把它挂载到&#x2F;boot上(以下是示例，不一定是mmcblk0p6，需根据实际情况决定)"></a>（2） 再把它挂载到&#x2F;boot上(以下是示例，不一定是mmcblk0p6，需根据实际情况决定)</h5><h6>参考：</h6><pre><code class="hljs">https://blog.csdn.net/qq_25231683/article/details/120018282</code></pre><h3 id="四、树莓派扩容"><a href="#四、树莓派扩容" class="headerlink" title="四、树莓派扩容"></a>四、树莓派扩容</h3><p>&ensp;&ensp;当树莓派默认的系统空间已经被占满，无法再进行安装等操作，而 SD卡仍有空间未被使用，可以对树莓派进行扩容。</p><p>&ensp;&ensp;假设一个镜像的大小为 4G，由于该镜像对内存卡的要求是大于或等于 4G，但对于 4G以上的内存卡来说，树莓派的系统只利用到 4G，因此才有了扩容这种操作。</p><h4 id="扩容步骤："><a href="#扩容步骤：" class="headerlink" title="扩容步骤："></a>扩容步骤：</h4><p>&ensp;&ensp;使用树莓派自带的工具可以快速将树莓派挂载所有的 SD卡空间，将系统分区扩展到 SD卡的最大容量。</p><h5 id="（1）打开raspi-config系统配置工具"><a href="#（1）打开raspi-config系统配置工具" class="headerlink" title="（1）打开raspi-config系统配置工具"></a>（1）打开raspi-config系统配置工具</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo raspi-config<br></code></pre></td></tr></table></figure><h5 id="（2）选择Advancd-Options："><a href="#（2）选择Advancd-Options：" class="headerlink" title="（2）选择Advancd Options："></a>（2）选择Advancd Options：</h5><h5 id="（3）选择Expand-Filesystem："><a href="#（3）选择Expand-Filesystem：" class="headerlink" title="（3）选择Expand Filesystem："></a>（3）选择Expand Filesystem：</h5><h5 id="（4）Ok："><a href="#（4）Ok：" class="headerlink" title="（4）Ok："></a>（4）Ok：</h5><h5 id="（5）重启树莓派"><a href="#（5）重启树莓派" class="headerlink" title="（5）重启树莓派"></a>（5）重启树莓派</h5><h6>参考：</h6><pre><code class="hljs">https://blog.csdn.net/lcx1837/article/details/114156732</code></pre><h3 id="五、超简单的树莓派SD卡扩容方案，将树莓派16GB的SD卡克隆到64GB的SD卡"><a href="#五、超简单的树莓派SD卡扩容方案，将树莓派16GB的SD卡克隆到64GB的SD卡" class="headerlink" title="五、超简单的树莓派SD卡扩容方案，将树莓派16GB的SD卡克隆到64GB的SD卡"></a>五、超简单的树莓派SD卡扩容方案，将树莓派16GB的SD卡克隆到64GB的SD卡</h3><h6>参考链接：</h6><pre><code class="hljs">https://blog.csdn.net/zhuoyuedelan/article/details/120684117</code></pre><h3 id="六、解决zsh：command-not-found问题"><a href="#六、解决zsh：command-not-found问题" class="headerlink" title="六、解决zsh：command not found问题"></a>六、解决zsh：command not found问题</h3><p><code>zsh: command not found:意思就是找不到这个命令，缺少环境变量的配置</code></p><h4 id="打开zsh配置文件"><a href="#打开zsh配置文件" class="headerlink" title="打开zsh配置文件"></a>打开zsh配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano ~/.zshrc<br></code></pre></td></tr></table></figure><h4 id="添加缺少的文件路径"><a href="#添加缺少的文件路径" class="headerlink" title="添加缺少的文件路径"></a>添加缺少的文件路径</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;/usr/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br><br><span class="hljs-built_in">export</span> PATH<br></code></pre></td></tr></table></figure><h4 id="关闭窗口执行"><a href="#关闭窗口执行" class="headerlink" title="关闭窗口执行"></a>关闭窗口执行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><h4 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">allure <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>&ensp;&ensp;在pycharm中验证安装成功是一样的方法，如果在终端验证成功，pycharm验证不成功，重启pycharm。</p><h3 id="七、SSH连接失败，解决-Host-key-verification-failed"><a href="#七、SSH连接失败，解决-Host-key-verification-failed" class="headerlink" title="七、SSH连接失败，解决 Host key verification failed."></a>七、SSH连接失败，解决 Host key verification failed.</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">ssh</span>-keygen -R 你要访问的<span class="hljs-built_in">IP</span>地址<br></code></pre></td></tr></table></figure><h3 id="八、树莓派打开vnc服务"><a href="#八、树莓派打开vnc服务" class="headerlink" title="八、树莓派打开vnc服务"></a>八、树莓派打开vnc服务</h3><p>&ensp;&ensp;树莓派命令行中，输入：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo raspi-config<br></code></pre></td></tr></table></figure><p>&ensp;&ensp;这会儿会打开一个图形化界面，界面中使用方向键控制光标，Enter键进行选择。需要说明的是，如果下面的说明中，你的树莓派没有对应选项，那可能因为版本原因，选项在不同的入口。否则的话请忽略。</p><h6>配置步骤：</h6><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">（<span class="hljs-number">1</span>）打开VNC：Interfacing <span class="hljs-keyword">Options</span> -&gt; VNC -&gt; Yes<br><br>（<span class="hljs-number">2</span>）退出图形化界面：（左右方向键选择）Finish。这时，无需重启即可使用vnc服务<br></code></pre></td></tr></table></figure><h3 id="九、解决Host-key-verification-failed"><a href="#九、解决Host-key-verification-failed" class="headerlink" title="九、解决Host key verification failed."></a>九、解决Host key verification failed.</h3><p>&ensp;&ensp;SSh连接树莓派时出现</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Host</span> key for <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.x has changed and you have requested strict checking.<br><br><span class="hljs-attribute">Host</span> key verification failed.<br></code></pre></td></tr></table></figure><p>&ensp;&ensp;这种情况一般是你重置过你的服务器后，你再次访问时Host key对不上，重置一下就好。</p><h6>解决办法：</h6><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">ssh</span>-keygen -R 你要访问的<span class="hljs-built_in">IP</span>地址     <br></code></pre></td></tr></table></figure><h3 id="十、Linux常用命令"><a href="#十、Linux常用命令" class="headerlink" title="十、Linux常用命令"></a>十、Linux常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看ip地址</span><br><br>ip a<br><br>ip addr<br><br>ifconfig<br><br><span class="hljs-comment">#ping网络(测试网络连通)</span><br><br>ping<br><br><span class="hljs-comment">#查看系统时间</span><br><br><span class="hljs-built_in">date</span><br><br><span class="hljs-comment">#注销</span><br><br><span class="hljs-built_in">logout</span><br><br><span class="hljs-comment">#关机</span><br><br>shutdown now<br><br><span class="hljs-comment">#重启</span><br><br>reboot<br><br><span class="hljs-comment">#清屏</span><br><br>clear<br><br><span class="hljs-comment">#查看磁盘空间大小</span><br><br><span class="hljs-built_in">df</span> -h<br><br><span class="hljs-comment">#查看内存剩余空间大小</span><br><br>free -m<br><br><span class="hljs-comment">#查看文件内容</span><br><br><span class="hljs-built_in">cat</span><br><br><span class="hljs-comment">#查看进程</span><br><br>ps -a<br><br>ps -e<br><br>top<br><br><span class="hljs-comment">#结束进程</span><br><br><span class="hljs-built_in">kill</span> pid<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/23/hello-world/"/>
    <url>/2023/08/23/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
